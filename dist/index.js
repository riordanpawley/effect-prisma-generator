#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const generator_helper_1 = require("@prisma/generator-helper");
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const header = `// This file was generated by prisma-effect-generator, do not edit manually.\n`;
// Utility function to convert PascalCase to camelCase
function toCamelCase(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}
(0, generator_helper_1.generatorHandler)({
    onManifest() {
        return {
            defaultOutput: "../generated/effect",
            prettyName: "Prisma Effect Generator",
            // No engines required - we only read the DMMF schema
            requiresEngines: [],
        };
    },
    async onGenerate(options) {
        const models = options.dmmf.datamodel.models;
        const outputDir = options.generator.output?.value;
        const configPath = options.generator.config.clientImportPath;
        const clientImportPath = Array.isArray(configPath)
            ? configPath[0]
            : (configPath ?? "@prisma/client");
        if (!outputDir) {
            throw new Error("No output directory specified");
        }
        // Clean output directory
        await promises_1.default.rm(outputDir, { recursive: true, force: true });
        await promises_1.default.mkdir(outputDir, { recursive: true });
        // Generate unified index file with PrismaService
        await generateUnifiedService([...models], outputDir, clientImportPath);
    },
});
function generateRawSqlOperations() {
    return `
    $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.flatMap(PrismaClientService, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
          catch: (error) => mapError(error, "$executeRaw", "Prisma")
        })
      ),

    $executeRawUnsafe: (query: string, ...values: any[]) =>
      Effect.flatMap(PrismaClientService, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => client.$executeRawUnsafe(query, ...values),
          catch: (error) => mapError(error, "$executeRawUnsafe", "Prisma")
        })
      ),

    $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.flatMap(PrismaClientService, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)),
          catch: (error) => mapError(error, "$queryRaw", "Prisma")
        })
      ),

    $queryRawUnsafe: (query: string, ...values: any[]) =>
      Effect.flatMap(PrismaClientService, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => client.$queryRawUnsafe(query, ...values),
          catch: (error) => mapError(error, "$queryRawUnsafe", "Prisma")
        })
      ),`;
}
function generateModelOperations(models) {
    return models
        .map((model) => {
        const modelName = model.name;
        const modelNameCamel = toCamelCase(modelName);
        // Type alias for the model delegate (e.g., PrismaClient['user'])
        const delegate = `PrismaClient['${modelNameCamel}']`;
        // Cast Promise results to ensure consistent typing across Prisma versions
        // This handles Prisma 7's GlobalOmitConfig and works fine with Prisma 6 too
        const promiseCast = (op, nullable = false) => {
            const resultType = `Prisma.Result<${delegate}, A, '${op}'>`;
            const fullType = nullable ? `${resultType} | null` : resultType;
            return ` as Promise<${fullType}>`;
        };
        // Aggregate/groupBy use complex internal types that need stronger casts
        const strongPromiseCast = (op) => {
            const resultType = `Prisma.Result<${delegate}, A, '${op}'>`;
            return ` as unknown as Promise<${resultType}>`;
        };
        const resultType = (op, nullable = false) => {
            const baseType = `Prisma.Result<${delegate}, A, '${op}'>`;
            return nullable ? `${baseType} | null` : baseType;
        };
        return `    ${modelNameCamel}: {
      findUnique: <A extends Prisma.Args<${delegate}, 'findUnique'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'findUnique'>>
      ): Effect.Effect<${resultType('findUnique', true)}, PrismaFindError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUnique(args as any)${promiseCast('findUnique', true)},
            catch: (error) => mapFindError(error, "findUnique", "${modelName}")
          })
        ),

      findUniqueOrThrow: <A extends Prisma.Args<${delegate}, 'findUniqueOrThrow'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'findUniqueOrThrow'>>
      ): Effect.Effect<${resultType('findUniqueOrThrow')}, PrismaFindOrThrowError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUniqueOrThrow(args as any)${promiseCast('findUniqueOrThrow')},
            catch: (error) => mapFindOrThrowError(error, "findUniqueOrThrow", "${modelName}")
          })
        ),

      findFirst: <A extends Prisma.Args<${delegate}, 'findFirst'> = {}>(
        args?: Prisma.Exact<A, Prisma.Args<${delegate}, 'findFirst'>>
      ): Effect.Effect<${resultType('findFirst', true)}, PrismaFindError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirst(args as any)${promiseCast('findFirst', true)},
            catch: (error) => mapFindError(error, "findFirst", "${modelName}")
          })
        ),

      findFirstOrThrow: <A extends Prisma.Args<${delegate}, 'findFirstOrThrow'> = {}>(
        args?: Prisma.Exact<A, Prisma.Args<${delegate}, 'findFirstOrThrow'>>
      ): Effect.Effect<${resultType('findFirstOrThrow')}, PrismaFindOrThrowError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirstOrThrow(args as any)${promiseCast('findFirstOrThrow')},
            catch: (error) => mapFindOrThrowError(error, "findFirstOrThrow", "${modelName}")
          })
        ),

      findMany: <A extends Prisma.Args<${delegate}, 'findMany'> = {}>(
        args?: Prisma.Exact<A, Prisma.Args<${delegate}, 'findMany'>>
      ): Effect.Effect<${resultType('findMany')}, PrismaFindError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findMany(args as any)${promiseCast('findMany')},
            catch: (error) => mapFindError(error, "findMany", "${modelName}")
          })
        ),

      create: <A extends Prisma.Args<${delegate}, 'create'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'create'>>
      ): Effect.Effect<${resultType('create')}, PrismaCreateError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.create(args as any)${promiseCast('create')},
            catch: (error) => mapCreateError(error, "create", "${modelName}")
          })
        ),

      createMany: (
        args?: Prisma.Args<${delegate}, 'createMany'>
      ): Effect.Effect<Prisma.BatchPayload, PrismaCreateError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createMany(args as any),
            catch: (error) => mapCreateError(error, "createMany", "${modelName}")
          })
        ),

      createManyAndReturn: <A extends Prisma.Args<${delegate}, 'createManyAndReturn'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'createManyAndReturn'>>
      ): Effect.Effect<${resultType('createManyAndReturn')}, PrismaCreateError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createManyAndReturn(args as any)${promiseCast('createManyAndReturn')},
            catch: (error) => mapCreateError(error, "createManyAndReturn", "${modelName}")
          })
        ),

      delete: <A extends Prisma.Args<${delegate}, 'delete'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'delete'>>
      ): Effect.Effect<${resultType('delete')}, PrismaDeleteError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.delete(args as any)${promiseCast('delete')},
            catch: (error) => mapDeleteError(error, "delete", "${modelName}")
          })
        ),

      update: <A extends Prisma.Args<${delegate}, 'update'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'update'>>
      ): Effect.Effect<${resultType('update')}, PrismaUpdateError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.update(args as any)${promiseCast('update')},
            catch: (error) => mapUpdateError(error, "update", "${modelName}")
          })
        ),

      deleteMany: (
        args?: Prisma.Args<${delegate}, 'deleteMany'>
      ): Effect.Effect<Prisma.BatchPayload, PrismaDeleteManyError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.deleteMany(args as any),
            catch: (error) => mapDeleteManyError(error, "deleteMany", "${modelName}")
          })
        ),

      updateMany: (
        args: Prisma.Args<${delegate}, 'updateMany'>
      ): Effect.Effect<Prisma.BatchPayload, PrismaUpdateManyError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateMany(args as any),
            catch: (error) => mapUpdateManyError(error, "updateMany", "${modelName}")
          })
        ),

      updateManyAndReturn: <A extends Prisma.Args<${delegate}, 'updateManyAndReturn'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'updateManyAndReturn'>>
      ): Effect.Effect<${resultType('updateManyAndReturn')}, PrismaUpdateManyError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateManyAndReturn(args as any)${promiseCast('updateManyAndReturn')},
            catch: (error) => mapUpdateManyError(error, "updateManyAndReturn", "${modelName}")
          })
        ),

      upsert: <A extends Prisma.Args<${delegate}, 'upsert'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'upsert'>>
      ): Effect.Effect<${resultType('upsert')}, PrismaCreateError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.upsert(args as any)${promiseCast('upsert')},
            catch: (error) => mapCreateError(error, "upsert", "${modelName}")
          })
        ),

      // Aggregation operations
      count: <A extends Prisma.Args<${delegate}, 'count'> = {}>(
        args?: Prisma.Exact<A, Prisma.Args<${delegate}, 'count'>>
      ): Effect.Effect<${resultType('count')}, PrismaFindError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.count(args as any)${promiseCast('count')},
            catch: (error) => mapFindError(error, "count", "${modelName}")
          })
        ),

      aggregate: <A extends Prisma.Args<${delegate}, 'aggregate'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'aggregate'>>
      ): Effect.Effect<${resultType('aggregate')}, PrismaFindError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.aggregate(args as any)${strongPromiseCast('aggregate')},
            catch: (error) => mapFindError(error, "aggregate", "${modelName}")
          })
        ),

      groupBy: <A extends Prisma.Args<${delegate}, 'groupBy'>>(
        args: Prisma.Exact<A, Prisma.Args<${delegate}, 'groupBy'>>
      ): Effect.Effect<${resultType('groupBy')}, PrismaFindError, PrismaClientService> =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.groupBy(args as any)${strongPromiseCast('groupBy')},
            catch: (error) => mapFindError(error, "groupBy", "${modelName}")
          })
        )
    }`;
    })
        .join(",\n\n");
}
async function generateUnifiedService(models, outputDir, clientImportPath) {
    const rawSqlOperations = generateRawSqlOperations();
    const modelOperations = generateModelOperations(models);
    const serviceContent = `${header}
import { Cause, Context, Data, Effect, Exit, Layer, Runtime } from "effect"
import { Service } from "effect/Effect"
import { Prisma, PrismaClient } from "${clientImportPath}"

export class PrismaClientService extends Context.Tag("PrismaClientService")<
  PrismaClientService,
  {
    tx: PrismaClient | Prisma.TransactionClient
    client: PrismaClient
  }
>() {}

/**
 * Create a PrismaClientService layer with the given options.
 *
 * @example
 * // Prisma 6 with defaults
 * const layer = makePrismaLayer({})
 *
 * // With datasource URL override
 * const layer = makePrismaLayer({ datasourceUrl: process.env.DATABASE_URL })
 *
 * // Prisma 7 with adapter (required in v7)
 * const layer = makePrismaLayer({ adapter: myAdapter })
 */
export const makePrismaLayer = <T extends ConstructorParameters<typeof PrismaClient>[0]>(options: T) => Layer.effect(
  PrismaClientService,
  Effect.sync(() => {
    const prisma = new PrismaClient(options)
    return {
      tx: prisma,
      client: prisma
    }
  })
)

/**
 * Default layer that creates a PrismaClient with no options.
 * Works with Prisma 6. For Prisma 7, use makePrismaLayer with adapter/accelerateUrl.
 */
export const LivePrismaLayer = makePrismaLayer({} as ConstructorParameters<typeof PrismaClient>[0])

export class PrismaUniqueConstraintError extends Data.TaggedError("PrismaUniqueConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError("PrismaForeignKeyConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRecordNotFoundError extends Data.TaggedError("PrismaRecordNotFoundError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelationViolationError extends Data.TaggedError("PrismaRelationViolationError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelatedRecordNotFoundError extends Data.TaggedError("PrismaRelatedRecordNotFoundError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaTransactionConflictError extends Data.TaggedError("PrismaTransactionConflictError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueTooLongError extends Data.TaggedError("PrismaValueTooLongError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueOutOfRangeError extends Data.TaggedError("PrismaValueOutOfRangeError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaDbConstraintError extends Data.TaggedError("PrismaDbConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaConnectionError extends Data.TaggedError("PrismaConnectionError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaMissingRequiredValueError extends Data.TaggedError("PrismaMissingRequiredValueError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaInputValidationError extends Data.TaggedError("PrismaInputValidationError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export type PrismaCreateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaDeleteError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaFindOrThrowError =
  | PrismaConnectionError
  | PrismaRecordNotFoundError

export type PrismaFindError =
  | PrismaConnectionError

export type PrismaDeleteManyError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateManyError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

// Generic mapper for raw operations and fallback
const mapError = (error: unknown, operation: string, model: string): PrismaError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  // Unknown errors are not handled and will be treated as defects
  throw error;
}

// Specific mappers to narrow error types per operation

// Create, Upsert
const mapCreateError = (error: unknown, operation: string, model: string): PrismaCreateError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Update
const mapUpdateError = (error: unknown, operation: string, model: string): PrismaUpdateError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Delete
const mapDeleteError = (error: unknown, operation: string, model: string): PrismaDeleteError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// FindOrThrow
const mapFindOrThrowError = (error: unknown, operation: string, model: string): PrismaFindOrThrowError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Find
const mapFindError = (error: unknown, operation: string, model: string): PrismaFindError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
    }
  }
  throw error;
}

// DeleteMany
const mapDeleteManyError = (error: unknown, operation: string, model: string): PrismaDeleteManyError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// UpdateMany
const mapUpdateManyError = (error: unknown, operation: string, model: string): PrismaUpdateManyError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

export class PrismaService extends Service<PrismaService>()("PrismaService", {
  effect: Effect.gen(function* () {
    return {
      $transaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: {
          maxWait?: number
          timeout?: number
          isolationLevel?: Prisma.TransactionIsolationLevel
        }
      ) =>
        Effect.flatMap(
          Effect.all([PrismaClientService, Effect.runtime<R>()]),
          ([{ client, tx }, runtime]): Effect.Effect<A, E | PrismaError, R> => {
            const isRootClient = "$transaction" in tx;
            if (!isRootClient) {
              return effect
            }
            return Effect.tryPromise({
              try: () =>
                client.$transaction(async (tx) => {
                  const exit = await Runtime.runPromiseExit(runtime)(
                    effect.pipe(
                      Effect.provideService(PrismaClientService, {
                        tx,
                        client,
                      }),
                    ) as Effect.Effect<A, E, R>,
                  )
                  if (Exit.isSuccess(exit)) {
                    return exit.value
                  }
                  throw Cause.squash(exit.cause)
                }, options),
              catch: (error) => error as E,
            }) as unknown as Effect.Effect<A, E, R>;
          }
        ),
      ${rawSqlOperations}

      ${modelOperations}
    }
  })
}) {}
`;
    await promises_1.default.writeFile(node_path_1.default.join(outputDir, "index.ts"), serviceContent);
}

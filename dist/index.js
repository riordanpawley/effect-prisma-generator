#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const generator_helper_1 = require("@prisma/generator-helper");
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const header = `// This file was generated by prisma-effect-generator, do not edit manually.\n`;
// Utility function to convert PascalCase to camelCase
function toCamelCase(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}
(0, generator_helper_1.generatorHandler)({
    onManifest() {
        return {
            defaultOutput: "../generated/effect",
            prettyName: "Prisma Effect Generator",
            // No engines required - we only read the DMMF schema
            requiresEngines: [],
        };
    },
    async onGenerate(options) {
        const models = options.dmmf.datamodel.models;
        const outputDir = options.generator.output?.value;
        const schemaDir = node_path_1.default.dirname(options.schemaPath);
        const configPath = options.generator.config.clientImportPath;
        const clientImportPath = Array.isArray(configPath)
            ? configPath[0]
            : (configPath ?? "@prisma/client");
        // Custom error configuration: "path/to/module#ErrorClassName"
        // Path is relative to schema.prisma, e.g., "./errors#PrismaError"
        // The module must export:
        //   - The error class (e.g., `export class PrismaError extends ...`)
        //   - A mapper function named `mapPrismaError` with signature:
        //     `(error: unknown, operation: string, model: string) => YourErrorType`
        const errorConfigRaw = options.generator.config.errorImportPath;
        const errorImportPathRaw = Array.isArray(errorConfigRaw)
            ? errorConfigRaw[0]
            : errorConfigRaw;
        // Import file extension for generated imports (e.g., "js", "ts", or "" for no extension)
        // Useful for ESM compatibility where imports need explicit extensions
        const importExtConfigRaw = options.generator.config.importFileExtension;
        const importFileExtension = Array.isArray(importExtConfigRaw)
            ? importExtConfigRaw[0]
            : (importExtConfigRaw ?? "");
        if (!outputDir) {
            throw new Error("No output directory specified");
        }
        // Helper to add file extension to a path if configured
        const addExtension = (filePath) => {
            if (!importFileExtension)
                return filePath;
            // Don't add extension if path already has one
            const ext = node_path_1.default.extname(filePath);
            if (ext)
                return filePath;
            return `${filePath}.${importFileExtension}`;
        };
        // Convert errorImportPath from schema-relative to output-relative
        let errorImportPath;
        if (errorImportPathRaw) {
            const [modulePath, className] = errorImportPathRaw.split("#");
            if (!modulePath || !className) {
                throw new Error(`Invalid errorImportPath format: "${errorImportPathRaw}". Expected "path/to/module#ErrorClassName"`);
            }
            // If it's a relative path, convert from schema-relative to output-relative
            if (modulePath.startsWith(".")) {
                const absoluteErrorPath = node_path_1.default.resolve(schemaDir, modulePath);
                const relativeToOutput = node_path_1.default.relative(outputDir, absoluteErrorPath);
                // Ensure it starts with ./ or ../
                const normalizedPath = relativeToOutput.startsWith(".")
                    ? relativeToOutput
                    : `./${relativeToOutput}`;
                // Add file extension if configured
                const pathWithExtension = addExtension(normalizedPath);
                errorImportPath = `${pathWithExtension}#${className}`;
            }
            else {
                // Package import (e.g., "@myorg/errors#PrismaError"), use as-is
                errorImportPath = errorImportPathRaw;
            }
        }
        // Clean output directory
        await promises_1.default.rm(outputDir, { recursive: true, force: true });
        await promises_1.default.mkdir(outputDir, { recursive: true });
        // Generate unified index file with PrismaService
        await generateUnifiedService([...models], outputDir, clientImportPath, errorImportPath);
    },
});
function generateRawSqlOperations(customError) {
    // With custom error, use mapError which maps to user's error type
    // Without custom error, use mapError which maps to PrismaError union
    const errorType = customError ? customError.className : "PrismaError";
    return `
    $executeRaw: (args: PrismaNamespace.Sql | [PrismaNamespace.Sql, ...any[]]): Effect.Effect<number, ${errorType}, PrismaClient> =>
      Effect.flatMap(PrismaClient, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
          catch: (error) => mapError(error, "$executeRaw", "Prisma")
        })
      ),

    $executeRawUnsafe: (query: string, ...values: any[]): Effect.Effect<number, ${errorType}, PrismaClient> =>
      Effect.flatMap(PrismaClient, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => client.$executeRawUnsafe(query, ...values),
          catch: (error) => mapError(error, "$executeRawUnsafe", "Prisma")
        })
      ),

    $queryRaw: <T = unknown>(args: PrismaNamespace.Sql | [PrismaNamespace.Sql, ...any[]]): Effect.Effect<T, ${errorType}, PrismaClient> =>
      Effect.flatMap(PrismaClient, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)) as Promise<T>,
          catch: (error) => mapError(error, "$queryRaw", "Prisma")
        })
      ),

    $queryRawUnsafe: <T = unknown>(query: string, ...values: any[]): Effect.Effect<T, ${errorType}, PrismaClient> =>
      Effect.flatMap(PrismaClient, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => client.$queryRawUnsafe(query, ...values) as Promise<T>,
          catch: (error) => mapError(error, "$queryRawUnsafe", "Prisma")
        })
      ),`;
}
/**
 * Generate type aliases for a model to reduce redundant type computation.
 * TypeScript performance is significantly improved when complex types are
 * computed once and reused via aliases rather than inline.
 */
function generateModelTypeAliases(models) {
    return models
        .map((model) => {
        const modelName = model.name;
        const modelNameCamel = toCamelCase(modelName);
        // Operations that need Args/Result type aliases
        const operations = [
            'findUnique', 'findUniqueOrThrow', 'findFirst', 'findFirstOrThrow',
            'findMany', 'create', 'createMany', 'createManyAndReturn',
            'delete', 'update', 'deleteMany', 'updateMany', 'updateManyAndReturn',
            'upsert', 'count', 'aggregate', 'groupBy'
        ];
        const argsAliases = operations
            .map(op => `type ${modelName}${capitalize(op)}Args = PrismaNamespace.Args<BasePrismaClient['${modelNameCamel}'], '${op}'>`)
            .join('\n');
        return argsAliases;
    })
        .join('\n\n');
}
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
function generateModelOperations(models, customError) {
    return models
        .map((model) => {
        const modelName = model.name;
        const modelNameCamel = toCamelCase(modelName);
        // Use pre-computed type alias for delegate
        const delegate = `BasePrismaClient['${modelNameCamel}']`;
        // Helper to get pre-computed Args type alias
        const argsType = (op) => `${modelName}${capitalize(op)}Args`;
        // Cast Promise results to ensure consistent typing across Prisma versions
        // This handles Prisma 7's GlobalOmitConfig and works fine with Prisma 6 too
        const promiseCast = (op, nullable = false) => {
            const resultType = `PrismaNamespace.Result<${delegate}, A, '${op}'>`;
            const fullType = nullable ? `${resultType} | null` : resultType;
            return ` as Promise<${fullType}>`;
        };
        // Aggregate/groupBy use complex internal types that need stronger casts
        const strongPromiseCast = (op) => {
            const resultType = `PrismaNamespace.Result<${delegate}, A, '${op}'>`;
            return ` as unknown as Promise<${resultType}>`;
        };
        const resultType = (op, nullable = false) => {
            const baseType = `PrismaNamespace.Result<${delegate}, A, '${op}'>`;
            return nullable ? `${baseType} | null` : baseType;
        };
        // With custom error: all operations use single error type and mapError
        // Without custom error: use per-operation error types and mappers
        const errorType = (opErrorType) => customError ? customError.className : opErrorType;
        const mapperFn = (defaultMapper) => customError ? "mapError" : defaultMapper;
        // Optimized signatures:
        // - Use pre-computed Args type aliases instead of inline PrismaNamespace.Args
        // - Remove Exact wrapper - the extends constraint already provides type safety
        // - This reduces TypeScript's type computation workload significantly
        return `    ${modelNameCamel}: {
      findUnique: <A extends ${argsType('findUnique')}>(
        args: A
      ): Effect.Effect<${resultType('findUnique', true)}, ${errorType('PrismaFindError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUnique(args as any)${promiseCast('findUnique', true)},
            catch: (error) => ${mapperFn('mapFindError')}(error, "findUnique", "${modelName}")
          })
        ),

      findUniqueOrThrow: <A extends ${argsType('findUniqueOrThrow')}>(
        args: A
      ): Effect.Effect<${resultType('findUniqueOrThrow')}, ${errorType('PrismaFindOrThrowError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUniqueOrThrow(args as any)${promiseCast('findUniqueOrThrow')},
            catch: (error) => ${mapperFn('mapFindOrThrowError')}(error, "findUniqueOrThrow", "${modelName}")
          })
        ),

      findFirst: <A extends ${argsType('findFirst')} = {}>(
        args?: A
      ): Effect.Effect<${resultType('findFirst', true)}, ${errorType('PrismaFindError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirst(args as any)${promiseCast('findFirst', true)},
            catch: (error) => ${mapperFn('mapFindError')}(error, "findFirst", "${modelName}")
          })
        ),

      findFirstOrThrow: <A extends ${argsType('findFirstOrThrow')} = {}>(
        args?: A
      ): Effect.Effect<${resultType('findFirstOrThrow')}, ${errorType('PrismaFindOrThrowError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirstOrThrow(args as any)${promiseCast('findFirstOrThrow')},
            catch: (error) => ${mapperFn('mapFindOrThrowError')}(error, "findFirstOrThrow", "${modelName}")
          })
        ),

      findMany: <A extends ${argsType('findMany')} = {}>(
        args?: A
      ): Effect.Effect<${resultType('findMany')}, ${errorType('PrismaFindError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findMany(args as any)${promiseCast('findMany')},
            catch: (error) => ${mapperFn('mapFindError')}(error, "findMany", "${modelName}")
          })
        ),

      create: <A extends ${argsType('create')}>(
        args: A
      ): Effect.Effect<${resultType('create')}, ${errorType('PrismaCreateError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.create(args as any)${promiseCast('create')},
            catch: (error) => ${mapperFn('mapCreateError')}(error, "create", "${modelName}")
          })
        ),

      createMany: (
        args?: ${argsType('createMany')}
      ): Effect.Effect<PrismaNamespace.BatchPayload, ${errorType('PrismaCreateError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createMany(args as any),
            catch: (error) => ${mapperFn('mapCreateError')}(error, "createMany", "${modelName}")
          })
        ),

      createManyAndReturn: <A extends ${argsType('createManyAndReturn')}>(
        args: A
      ): Effect.Effect<${resultType('createManyAndReturn')}, ${errorType('PrismaCreateError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createManyAndReturn(args as any)${promiseCast('createManyAndReturn')},
            catch: (error) => ${mapperFn('mapCreateError')}(error, "createManyAndReturn", "${modelName}")
          })
        ),

      delete: <A extends ${argsType('delete')}>(
        args: A
      ): Effect.Effect<${resultType('delete')}, ${errorType('PrismaDeleteError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.delete(args as any)${promiseCast('delete')},
            catch: (error) => ${mapperFn('mapDeleteError')}(error, "delete", "${modelName}")
          })
        ),

      update: <A extends ${argsType('update')}>(
        args: A
      ): Effect.Effect<${resultType('update')}, ${errorType('PrismaUpdateError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.update(args as any)${promiseCast('update')},
            catch: (error) => ${mapperFn('mapUpdateError')}(error, "update", "${modelName}")
          })
        ),

      deleteMany: (
        args?: ${argsType('deleteMany')}
      ): Effect.Effect<PrismaNamespace.BatchPayload, ${errorType('PrismaDeleteManyError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.deleteMany(args as any),
            catch: (error) => ${mapperFn('mapDeleteManyError')}(error, "deleteMany", "${modelName}")
          })
        ),

      updateMany: (
        args: ${argsType('updateMany')}
      ): Effect.Effect<PrismaNamespace.BatchPayload, ${errorType('PrismaUpdateManyError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateMany(args as any),
            catch: (error) => ${mapperFn('mapUpdateManyError')}(error, "updateMany", "${modelName}")
          })
        ),

      updateManyAndReturn: <A extends ${argsType('updateManyAndReturn')}>(
        args: A
      ): Effect.Effect<${resultType('updateManyAndReturn')}, ${errorType('PrismaUpdateManyError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateManyAndReturn(args as any)${promiseCast('updateManyAndReturn')},
            catch: (error) => ${mapperFn('mapUpdateManyError')}(error, "updateManyAndReturn", "${modelName}")
          })
        ),

      upsert: <A extends ${argsType('upsert')}>(
        args: A
      ): Effect.Effect<${resultType('upsert')}, ${errorType('PrismaCreateError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.upsert(args as any)${promiseCast('upsert')},
            catch: (error) => ${mapperFn('mapCreateError')}(error, "upsert", "${modelName}")
          })
        ),

      // Aggregation operations
      count: <A extends ${argsType('count')} = {}>(
        args?: A
      ): Effect.Effect<${resultType('count')}, ${errorType('PrismaFindError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.count(args as any)${promiseCast('count')},
            catch: (error) => ${mapperFn('mapFindError')}(error, "count", "${modelName}")
          })
        ),

      aggregate: <A extends ${argsType('aggregate')}>(
        args: A
      ): Effect.Effect<${resultType('aggregate')}, ${errorType('PrismaFindError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.aggregate(args as any)${strongPromiseCast('aggregate')},
            catch: (error) => ${mapperFn('mapFindError')}(error, "aggregate", "${modelName}")
          })
        ),

      groupBy: <A extends ${argsType('groupBy')}>(
        args: A
      ): Effect.Effect<${resultType('groupBy')}, ${errorType('PrismaFindError')}, PrismaClient> =>
        Effect.flatMap(PrismaClient, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.groupBy(args as any)${strongPromiseCast('groupBy')},
            catch: (error) => ${mapperFn('mapFindError')}(error, "groupBy", "${modelName}")
          })
        )
    }`;
    })
        .join(",\n\n");
}
// Parse error import path like "./errors#PrismaError" into { path, className }
function parseErrorImportPath(errorImportPath) {
    if (!errorImportPath)
        return null;
    const [path, className] = errorImportPath.split("#");
    if (!path || !className) {
        throw new Error(`Invalid errorImportPath format: "${errorImportPath}". Expected "path/to/module#ErrorClassName"`);
    }
    return { path, className };
}
async function generateUnifiedService(models, outputDir, clientImportPath, errorImportPath) {
    const customError = parseErrorImportPath(errorImportPath);
    const rawSqlOperations = generateRawSqlOperations(customError);
    const modelTypeAliases = generateModelTypeAliases(models);
    const modelOperations = generateModelOperations(models, customError);
    // Generate different content based on whether custom error is configured
    const serviceContent = customError
        ? generateCustomErrorService(customError, clientImportPath, rawSqlOperations, modelTypeAliases, modelOperations)
        : generateDefaultErrorService(clientImportPath, rawSqlOperations, modelTypeAliases, modelOperations);
    await promises_1.default.writeFile(node_path_1.default.join(outputDir, "index.ts"), serviceContent);
}
/**
 * Generate service with custom user-provided error class.
 * All operations use a single error type and a simple mapError function.
 */
function generateCustomErrorService(customError, clientImportPath, rawSqlOperations, modelTypeAliases, modelOperations) {
    return `${header}
import { Context, Effect, Exit, Layer } from "effect"
import { Service } from "effect/Effect"
import { Prisma as PrismaNamespace, PrismaClient as BasePrismaClient } from "${clientImportPath}"
import { ${customError.className}, mapPrismaError } from "${customError.path}"

// ============================================================================
// Type aliases for model operations (performance optimization)
// These are computed once and reused, reducing TypeScript's type-checking workload
// ============================================================================

${modelTypeAliases}

// Symbol used to identify intentional rollbacks vs actual errors
const ROLLBACK = Symbol.for("prisma.effect.rollback")

// Type for the flat transaction client with commit/rollback control
type FlatTransactionClient = PrismaNamespace.TransactionClient & {
  $commit: () => Promise<void>
  $rollback: () => Promise<void>
}

/** Transaction options for $transaction and $isolatedTransaction */
type TransactionOptions = {
  maxWait?: number
  timeout?: number
  isolationLevel?: PrismaNamespace.TransactionIsolationLevel
}

/**
 * Context tag for the Prisma client instance.
 * Holds the transaction client (tx) and root client.
 *
 * Use \`PrismaClient.layer()\` or \`PrismaClient.layerEffect()\` to create a layer.
 *
 * @example
 * // Prisma 6 - all options are optional
 * const layer = PrismaClient.layer({ datasourceUrl: "..." })
 *
 * // Prisma 7 - adapter or accelerateUrl is required
 * const layer = PrismaClient.layer({ adapter: myAdapter })
 *
 * // With transaction options (Prisma uses these as defaults for $transaction)
 * const layer = PrismaClient.layer({
 *   adapter: myAdapter,  // or datasourceUrl for Prisma 6
 *   transactionOptions: { isolationLevel: "Serializable", timeout: 10000 }
 * })
 */
export class PrismaClient extends Context.Tag("PrismaClient")<
  PrismaClient,
  {
    tx: BasePrismaClient | PrismaNamespace.TransactionClient
    client: BasePrismaClient
  }
>() {
  /**
   * Create a PrismaClient layer with the given options.
   * The client will be automatically disconnected when the layer scope ends.
   *
   * Pass options directly - the signature matches PrismaClient's constructor.
   * Prisma 6: all options are optional
   * Prisma 7: requires either \`adapter\` or \`accelerateUrl\`
   *
   * @example
   * // Prisma 6
   * const layer = PrismaClient.layer({ datasourceUrl: process.env.DATABASE_URL })
   *
   * // Prisma 7 with adapter
   * const layer = PrismaClient.layer({ adapter: myAdapter })
   *
   * // With transaction options
   * const layer = PrismaClient.layer({
   *   adapter: myAdapter,
   *   transactionOptions: { isolationLevel: "Serializable" }
   * })
   */
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const prisma = new BasePrismaClient(...args)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )

  /**
   * Create a PrismaClient layer where options are computed via an Effect.
   * Useful when you need to fetch configuration from environment, config service, or create adapters.
   * The client will be automatically disconnected when the layer scope ends.
   *
   * @example
   * // Get config from a service
   * const layer = PrismaClient.layerEffect(
   *   Effect.gen(function* () {
   *     const config = yield* ConfigService
   *     return { adapter: createAdapter(config.databaseUrl) }
   *   })
   * )
   *
   * // With transaction options
   * const layer = PrismaClient.layerEffect(
   *   Effect.gen(function* () {
   *     return {
   *       adapter: myAdapter,
   *       transactionOptions: { isolationLevel: "Serializable" }
   *     }
   *   })
   * )
   */
  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const options = yield* optionsEffect
      const prisma = new BasePrismaClient(options)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )
}

// Re-export the custom error type for convenience
export { ${customError.className} }

// Use the user-provided error mapper
const mapError = mapPrismaError

/**
 * Internal helper to begin a callback-free interactive transaction.
 * Returns a transaction client with $commit and $rollback methods.
 * This allows transactions to run in the same fiber as the parent effect.
 */
const $begin = (
  client: BasePrismaClient,
  options?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: PrismaNamespace.TransactionIsolationLevel
  }
): Effect.Effect<FlatTransactionClient, ${customError.className}> =>
  Effect.async<FlatTransactionClient, ${customError.className}>((resume) => {
    let setTxClient: (txClient: PrismaNamespace.TransactionClient) => void
    let commit: () => void
    let rollback: () => void

    // Promise that resolves when we get the transaction client
    const txClientPromise = new Promise<PrismaNamespace.TransactionClient>((res) => {
      setTxClient = res
    })

    // Promise that controls when the transaction commits/rolls back
    const txPromise = new Promise<void>((_res, _rej) => {
      commit = () => _res(undefined)
      rollback = () => _rej(ROLLBACK)
    })

    // Start the transaction - Prisma will wait on txPromise before committing
    const tx = client.$transaction((txClient) => {
      setTxClient(txClient)
      return txPromise
    }, options).catch((e) => {
      // Swallow intentional rollbacks, rethrow actual errors
      if (e === ROLLBACK) return
      throw e
    })

    // Once we have the transaction client, wrap it with commit/rollback methods
    txClientPromise.then((innerTx) => {
      const proxy = new Proxy(innerTx, {
        get(target, prop) {
          if (prop === "$commit") return () => { commit(); return tx }
          if (prop === "$rollback") return () => { rollback(); return tx }
          return target[prop as keyof typeof target]
        },
      }) as FlatTransactionClient
      resume(Effect.succeed(proxy))
    }).catch((error) => {
      resume(Effect.fail(mapError(error, "$transaction", "Prisma")))
    })
  })

/**
 * The main Prisma service with all database operations.
 * Provides type-safe, effectful access to your Prisma models.
 *
 * @example
 * const program = Effect.gen(function* () {
 *   const prisma = yield* Prisma
 *   const user = yield* prisma.user.create({ data: { name: "Alice" } })
 *   return user
 * })
 *
 * // Run with default layer (Prisma 6)
 * Effect.runPromise(program.pipe(Effect.provide(Prisma.Live)))
 *
 * // Or with custom options
 * Effect.runPromise(program.pipe(Effect.provide(Prisma.layer({ datasourceUrl: "..." }))))
 */
export class Prisma extends Service<Prisma>()("Prisma", {
  effect: Effect.gen(function* () {
    return {
      /**
       * Execute an effect within a database transaction.
       * All operations within the effect will be atomic - they either all succeed or all fail.
       *
       * This implementation uses a callback-free transaction pattern that keeps the effect
       * running in the same fiber as the parent, preserving Ref, FiberRef, and Context access.
       *
       * Uses default transaction options from PrismaClient constructor.
       * For custom options, use \`$transactionWith\`.
       *
       * @example
       * const result = yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     const user = yield* prisma.user.create({ data: { name: "Alice" } })
       *     yield* prisma.post.create({ data: { title: "Hello", authorId: user.id } })
       *     return user
       *   })
       * )
       */
      $transaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client, tx }): Effect.Effect<A, E | ${customError.className}, R> => {
            // If we're already in a transaction, just run the effect directly (no nesting)
            const isRootClient = "$transaction" in tx
            if (!isRootClient) {
              return effect
            }

            // Use acquireUseRelease to manage the transaction lifecycle
            // This keeps everything in the same fiber, preserving Ref/FiberRef/Context
            return Effect.acquireUseRelease(
              // Acquire: begin a new transaction with default options
              $begin(client),

              // Use: run the effect with the transaction client injected
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),

              // Release: commit on success, rollback on failure/interruption
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      /**
       * Execute an effect within a database transaction with custom options.
       * All operations within the effect will be atomic - they either all succeed or all fail.
       *
       * This implementation uses a callback-free transaction pattern that keeps the effect
       * running in the same fiber as the parent, preserving Ref, FiberRef, and Context access.
       *
       * Options passed here override any defaults set in PrismaClient constructor.
       *
       * @example
       * // Override default isolation level for this transaction
       * const result = yield* prisma.$transactionWith(
       *   Effect.gen(function* () {
       *     const user = yield* prisma.user.create({ data: { name: "Alice" } })
       *     yield* prisma.post.create({ data: { title: "Hello", authorId: user.id } })
       *     return user
       *   }),
       *   { isolationLevel: "ReadCommitted", timeout: 10000 }
       * )
       */
      $transactionWith: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client, tx }): Effect.Effect<A, E | ${customError.className}, R> => {
            // If we're already in a transaction, just run the effect directly (no nesting)
            const isRootClient = "$transaction" in tx
            if (!isRootClient) {
              return effect
            }

            // Use acquireUseRelease to manage the transaction lifecycle
            // This keeps everything in the same fiber, preserving Ref/FiberRef/Context
            return Effect.acquireUseRelease(
              // Acquire: begin a new transaction
              // Prisma merges per-call options with constructor defaults internally
              $begin(client, options),

              // Use: run the effect with the transaction client injected
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),

              // Release: commit on success, rollback on failure/interruption
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      /**
       * Execute an effect in a NEW transaction, even if already inside a transaction.
       * Unlike \`$transaction\`, this always creates a fresh, independent transaction.
       *
       * Use this for operations that should NOT be rolled back with the parent:
       * - Audit logging that must persist even if main operation fails
       * - Saga pattern where each step has independent commit/rollback
       * - Background job queuing that should commit immediately
       *
       * ⚠️ WARNING: The isolated transaction can commit while the parent rolls back,
       * or vice versa. Use carefully to avoid data inconsistencies.
       *
       * Uses default transaction options from PrismaClient constructor.
       * For custom options, use \`$isolatedTransactionWith\`.
       *
       * @example
       * yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     // This audit log commits independently - survives parent rollback
       *     yield* prisma.$isolatedTransaction(
       *       prisma.auditLog.create({ data: { action: "attempt", userId } })
       *     )
       *     // Main operation - if this fails, audit log is still committed
       *     yield* prisma.user.delete({ where: { id: userId } })
       *   })
       * )
       */
      $isolatedTransaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client }): Effect.Effect<A, E | ${customError.className}, R> => {
            // Always use the root client to create a fresh transaction
            return Effect.acquireUseRelease(
              $begin(client),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      /**
       * Execute an effect in a NEW transaction with custom options, even if already inside a transaction.
       * Unlike \`$transaction\`, this always creates a fresh, independent transaction.
       *
       * Use this for operations that should NOT be rolled back with the parent:
       * - Audit logging that must persist even if main operation fails
       * - Saga pattern where each step has independent commit/rollback
       * - Background job queuing that should commit immediately
       *
       * ⚠️ WARNING: The isolated transaction can commit while the parent rolls back,
       * or vice versa. Use carefully to avoid data inconsistencies.
       *
       * Options passed here override any defaults set in PrismaClient constructor.
       *
       * @example
       * yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     // This audit log commits independently with custom isolation level
       *     yield* prisma.$isolatedTransactionWith(
       *       prisma.auditLog.create({ data: { action: "attempt", userId } }),
       *       { isolationLevel: "Serializable" }
       *     )
       *     // Main operation - if this fails, audit log is still committed
       *     yield* prisma.user.delete({ where: { id: userId } })
       *   })
       * )
       */
      $isolatedTransactionWith: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client }): Effect.Effect<A, E | ${customError.className}, R> => {
            // Always use the root client to create a fresh transaction
            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),
      ${rawSqlOperations}

      ${modelOperations}
    }
  })
}) {
  /**
   * Create a complete Prisma layer with the given PrismaClient options.
   * This is the recommended way to create a Prisma layer - it bundles both
   * PrismaClient and Prisma service together.
   *
   * Pass options directly - the signature matches PrismaClient's constructor.
   * Prisma 6: all options are optional
   * Prisma 7: requires either \`adapter\` or \`accelerateUrl\`
   *
   * @example
   * // Prisma 6
   * const MainLayer = Prisma.layer({ datasourceUrl: process.env.DATABASE_URL })
   *
   * // Prisma 7 with adapter
   * const MainLayer = Prisma.layer({ adapter: myAdapter })
   *
   * // With transaction options
   * const MainLayer = Prisma.layer({
   *   adapter: myAdapter,
   *   transactionOptions: { isolationLevel: "Serializable" }
   * })
   *
   * // Use it
   * Effect.runPromise(program.pipe(Effect.provide(MainLayer)))
   */
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.merge(PrismaClient.layer(...args), Prisma.Default)

  /**
   * Create a complete Prisma layer where PrismaClient options are computed via an Effect.
   * This is useful when you need to fetch configuration or create adapters using Effect.
   *
   * @example
   * // Get config from a service
   * const MainLayer = Prisma.layerEffect(
   *   Effect.gen(function* () {
   *     const config = yield* ConfigService
   *     return { adapter: createAdapter(config.databaseUrl) }
   *   })
   * )
   *
   * // With transaction options
   * const MainLayer = Prisma.layerEffect(
   *   Effect.gen(function* () {
   *     return {
   *       adapter: myAdapter,
   *       transactionOptions: { isolationLevel: "Serializable" }
   *     }
   *   })
   * )
   */
  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.merge(PrismaClient.layerEffect(optionsEffect), Prisma.Default)

}

// ============================================================================
// Deprecated aliases for backward compatibility
// ============================================================================

/**
 * @deprecated Use \`PrismaClient\` instead. Will be removed in next major version.
 */
export const PrismaClientService = PrismaClient

/**
 * @deprecated Use \`Prisma\` instead. Will be removed in next major version.
 */
export const PrismaService = Prisma

/**
 * @deprecated Use \`PrismaClient.layer()\` instead. Will be removed in next major version.
 */
export const makePrismaLayer = PrismaClient.layer

/**
 * @deprecated Use \`PrismaClient.layerEffect()\` instead. Will be removed in next major version.
 */
export const makePrismaLayerEffect = PrismaClient.layerEffect


`;
}
/**
 * Generate service with default tagged error classes.
 * Operations have per-operation error types for fine-grained error handling.
 */
function generateDefaultErrorService(clientImportPath, rawSqlOperations, modelTypeAliases, modelOperations) {
    return `${header}
import { Context, Data, Effect, Exit, Layer } from "effect"
import { Service } from "effect/Effect"
import { Prisma as PrismaNamespace, PrismaClient as BasePrismaClient } from "${clientImportPath}"

// ============================================================================
// Type aliases for model operations (performance optimization)
// These are computed once and reused, reducing TypeScript's type-checking workload
// ============================================================================

${modelTypeAliases}

// Symbol used to identify intentional rollbacks vs actual errors
const ROLLBACK = Symbol.for("prisma.effect.rollback")

// Type for the flat transaction client with commit/rollback control
type FlatTransactionClient = PrismaNamespace.TransactionClient & {
  $commit: () => Promise<void>
  $rollback: () => Promise<void>
}

/** Transaction options for $transaction and $isolatedTransaction */
type TransactionOptions = {
  maxWait?: number
  timeout?: number
  isolationLevel?: PrismaNamespace.TransactionIsolationLevel
}

/**
 * Context tag for the Prisma client instance.
 * Holds the transaction client (tx) and root client.
 *
 * Use \`PrismaClient.layer()\` or \`PrismaClient.layerEffect()\` to create a layer.
 *
 * @example
 * // Prisma 6 - all options are optional
 * const layer = PrismaClient.layer({ datasourceUrl: "..." })
 *
 * // Prisma 7 - adapter or accelerateUrl is required
 * const layer = PrismaClient.layer({ adapter: myAdapter })
 *
 * // With transaction options (Prisma uses these as defaults for $transaction)
 * const layer = PrismaClient.layer({
 *   adapter: myAdapter,  // or datasourceUrl for Prisma 6
 *   transactionOptions: { isolationLevel: "Serializable", timeout: 10000 }
 * })
 */
export class PrismaClient extends Context.Tag("PrismaClient")<
  PrismaClient,
  {
    tx: BasePrismaClient | PrismaNamespace.TransactionClient
    client: BasePrismaClient
  }
>() {
  /**
   * Create a PrismaClient layer with the given options.
   * The client will be automatically disconnected when the layer scope ends.
   *
   * Pass options directly - the signature matches PrismaClient's constructor.
   * Prisma 6: all options are optional
   * Prisma 7: requires either \`adapter\` or \`accelerateUrl\`
   *
   * @example
   * // Prisma 6
   * const layer = PrismaClient.layer({ datasourceUrl: process.env.DATABASE_URL })
   *
   * // Prisma 7 with adapter
   * const layer = PrismaClient.layer({ adapter: myAdapter })
   *
   * // With transaction options
   * const layer = PrismaClient.layer({
   *   adapter: myAdapter,
   *   transactionOptions: { isolationLevel: "Serializable" }
   * })
   */
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const prisma = new BasePrismaClient(...args)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )

  /**
   * Create a PrismaClient layer where options are computed via an Effect.
   * Useful when you need to fetch configuration from environment, config service, or create adapters.
   * The client will be automatically disconnected when the layer scope ends.
   *
   * @example
   * // Get config from a service
   * const layer = PrismaClient.layerEffect(
   *   Effect.gen(function* () {
   *     const config = yield* ConfigService
   *     return { adapter: createAdapter(config.databaseUrl) }
   *   })
   * )
   *
   * // With transaction options
   * const layer = PrismaClient.layerEffect(
   *   Effect.gen(function* () {
   *     return {
   *       adapter: myAdapter,
   *       transactionOptions: { isolationLevel: "Serializable" }
   *     }
   *   })
   * )
   */
  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const options = yield* optionsEffect
      const prisma = new BasePrismaClient(options)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )
}

export class PrismaUniqueConstraintError extends Data.TaggedError("PrismaUniqueConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError("PrismaForeignKeyConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRecordNotFoundError extends Data.TaggedError("PrismaRecordNotFoundError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelationViolationError extends Data.TaggedError("PrismaRelationViolationError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelatedRecordNotFoundError extends Data.TaggedError("PrismaRelatedRecordNotFoundError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaTransactionConflictError extends Data.TaggedError("PrismaTransactionConflictError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueTooLongError extends Data.TaggedError("PrismaValueTooLongError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueOutOfRangeError extends Data.TaggedError("PrismaValueOutOfRangeError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaDbConstraintError extends Data.TaggedError("PrismaDbConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaConnectionError extends Data.TaggedError("PrismaConnectionError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaMissingRequiredValueError extends Data.TaggedError("PrismaMissingRequiredValueError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaInputValidationError extends Data.TaggedError("PrismaInputValidationError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export type PrismaCreateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaDeleteError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaFindOrThrowError =
  | PrismaConnectionError
  | PrismaRecordNotFoundError

export type PrismaFindError =
  | PrismaConnectionError

export type PrismaDeleteManyError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateManyError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

// Generic mapper for raw operations and fallback
const mapError = (error: unknown, operation: string, model: string): PrismaError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  // Unknown errors are not handled and will be treated as defects
  throw error;
}

// Specific mappers to narrow error types per operation

// Create, Upsert
const mapCreateError = (error: unknown, operation: string, model: string): PrismaCreateError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Update
const mapUpdateError = (error: unknown, operation: string, model: string): PrismaUpdateError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Delete
const mapDeleteError = (error: unknown, operation: string, model: string): PrismaDeleteError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// FindOrThrow
const mapFindOrThrowError = (error: unknown, operation: string, model: string): PrismaFindOrThrowError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Find
const mapFindError = (error: unknown, operation: string, model: string): PrismaFindError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
    }
  }
  throw error;
}

// DeleteMany
const mapDeleteManyError = (error: unknown, operation: string, model: string): PrismaDeleteManyError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// UpdateMany
const mapUpdateManyError = (error: unknown, operation: string, model: string): PrismaUpdateManyError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

/**
 * Internal helper to begin a callback-free interactive transaction.
 * Returns a transaction client with $commit and $rollback methods.
 * This allows transactions to run in the same fiber as the parent effect.
 */
const $begin = (
  client: BasePrismaClient,
  options?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: PrismaNamespace.TransactionIsolationLevel
  }
): Effect.Effect<FlatTransactionClient, PrismaError> =>
  Effect.async<FlatTransactionClient, PrismaError>((resume) => {
    let setTxClient: (txClient: PrismaNamespace.TransactionClient) => void
    let commit: () => void
    let rollback: () => void

    // Promise that resolves when we get the transaction client
    const txClientPromise = new Promise<PrismaNamespace.TransactionClient>((res) => {
      setTxClient = res
    })

    // Promise that controls when the transaction commits/rolls back
    const txPromise = new Promise<void>((_res, _rej) => {
      commit = () => _res(undefined)
      rollback = () => _rej(ROLLBACK)
    })

    // Start the transaction - Prisma will wait on txPromise before committing
    const tx = client.$transaction((txClient) => {
      setTxClient(txClient)
      return txPromise
    }, options).catch((e) => {
      // Swallow intentional rollbacks, rethrow actual errors
      if (e === ROLLBACK) return
      throw e
    })

    // Once we have the transaction client, wrap it with commit/rollback methods
    txClientPromise.then((innerTx) => {
      const proxy = new Proxy(innerTx, {
        get(target, prop) {
          if (prop === "$commit") return () => { commit(); return tx }
          if (prop === "$rollback") return () => { rollback(); return tx }
          return target[prop as keyof typeof target]
        },
      }) as FlatTransactionClient
      resume(Effect.succeed(proxy))
    }).catch((error) => {
      resume(Effect.fail(mapError(error, "$transaction", "Prisma")))
    })
  })

/**
 * The main Prisma service with all database operations.
 * Provides type-safe, effectful access to your Prisma models.
 *
 * @example
 * const program = Effect.gen(function* () {
 *   const prisma = yield* Prisma
 *   const user = yield* prisma.user.create({ data: { name: "Alice" } })
 *   return user
 * })
 *
 * // Run with default layer (Prisma 6)
 * Effect.runPromise(program.pipe(Effect.provide(Prisma.Live)))
 *
 * // Or with custom options
 * Effect.runPromise(program.pipe(Effect.provide(Prisma.layer({ datasourceUrl: "..." }))))
 */
export class Prisma extends Service<Prisma>()("Prisma", {
  effect: Effect.gen(function* () {
    return {
      /**
       * Execute an effect within a database transaction.
       * All operations within the effect will be atomic - they either all succeed or all fail.
       *
       * This implementation uses a callback-free transaction pattern that keeps the effect
       * running in the same fiber as the parent, preserving Ref, FiberRef, and Context access.
       *
       * Uses default transaction options from PrismaClient constructor.
       * For custom options, use \`$transactionWith\`.
       *
       * @example
       * const result = yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     const user = yield* prisma.user.create({ data: { name: "Alice" } })
       *     yield* prisma.post.create({ data: { title: "Hello", authorId: user.id } })
       *     return user
       *   })
       * )
       */
      $transaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client, tx }): Effect.Effect<A, E | PrismaError, R> => {
            // If we're already in a transaction, just run the effect directly (no nesting)
            const isRootClient = "$transaction" in tx
            if (!isRootClient) {
              return effect
            }

            // Use acquireUseRelease to manage the transaction lifecycle
            // This keeps everything in the same fiber, preserving Ref/FiberRef/Context
            return Effect.acquireUseRelease(
              // Acquire: begin a new transaction with default options
              $begin(client),

              // Use: run the effect with the transaction client injected
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),

              // Release: commit on success, rollback on failure/interruption
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      /**
       * Execute an effect within a database transaction with custom options.
       * All operations within the effect will be atomic - they either all succeed or all fail.
       *
       * This implementation uses a callback-free transaction pattern that keeps the effect
       * running in the same fiber as the parent, preserving Ref, FiberRef, and Context access.
       *
       * Options passed here override any defaults set in PrismaClient constructor.
       *
       * @example
       * // Override default isolation level for this transaction
       * const result = yield* prisma.$transactionWith(
       *   Effect.gen(function* () {
       *     const user = yield* prisma.user.create({ data: { name: "Alice" } })
       *     yield* prisma.post.create({ data: { title: "Hello", authorId: user.id } })
       *     return user
       *   }),
       *   { isolationLevel: "ReadCommitted", timeout: 10000 }
       * )
       */
      $transactionWith: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client, tx }): Effect.Effect<A, E | PrismaError, R> => {
            // If we're already in a transaction, just run the effect directly (no nesting)
            const isRootClient = "$transaction" in tx
            if (!isRootClient) {
              return effect
            }

            // Use acquireUseRelease to manage the transaction lifecycle
            // This keeps everything in the same fiber, preserving Ref/FiberRef/Context
            return Effect.acquireUseRelease(
              // Acquire: begin a new transaction
              // Prisma merges per-call options with constructor defaults internally
              $begin(client, options),

              // Use: run the effect with the transaction client injected
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),

              // Release: commit on success, rollback on failure/interruption
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      /**
       * Execute an effect in a NEW transaction, even if already inside a transaction.
       * Unlike \`$transaction\`, this always creates a fresh, independent transaction.
       *
       * Use this for operations that should NOT be rolled back with the parent:
       * - Audit logging that must persist even if main operation fails
       * - Saga pattern where each step has independent commit/rollback
       * - Background job queuing that should commit immediately
       *
       * ⚠️ WARNING: The isolated transaction can commit while the parent rolls back,
       * or vice versa. Use carefully to avoid data inconsistencies.
       *
       * Uses default transaction options from PrismaClient constructor.
       * For custom options, use \`$isolatedTransactionWith\`.
       *
       * @example
       * yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     // This audit log commits independently - survives parent rollback
       *     yield* prisma.$isolatedTransaction(
       *       prisma.auditLog.create({ data: { action: "attempt", userId } })
       *     )
       *     // Main operation - if this fails, audit log is still committed
       *     yield* prisma.user.delete({ where: { id: userId } })
       *   })
       * )
       */
      $isolatedTransaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client }): Effect.Effect<A, E | PrismaError, R> => {
            // Always use the root client to create a fresh transaction
            return Effect.acquireUseRelease(
              $begin(client),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      /**
       * Execute an effect in a NEW transaction with custom options, even if already inside a transaction.
       * Unlike \`$transaction\`, this always creates a fresh, independent transaction.
       *
       * Use this for operations that should NOT be rolled back with the parent:
       * - Audit logging that must persist even if main operation fails
       * - Saga pattern where each step has independent commit/rollback
       * - Background job queuing that should commit immediately
       *
       * ⚠️ WARNING: The isolated transaction can commit while the parent rolls back,
       * or vice versa. Use carefully to avoid data inconsistencies.
       *
       * Options passed here override any defaults set in PrismaClient constructor.
       *
       * @example
       * yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     // This audit log commits independently with custom isolation level
       *     yield* prisma.$isolatedTransactionWith(
       *       prisma.auditLog.create({ data: { action: "attempt", userId } }),
       *       { isolationLevel: "Serializable" }
       *     )
       *     // Main operation - if this fails, audit log is still committed
       *     yield* prisma.user.delete({ where: { id: userId } })
       *   })
       * )
       */
      $isolatedTransactionWith: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client }): Effect.Effect<A, E | PrismaError, R> => {
            // Always use the root client to create a fresh transaction
            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),
      ${rawSqlOperations}

      ${modelOperations}
    }
  })
}) {
  /**
   * Create a complete Prisma layer with the given PrismaClient options.
   * This is the recommended way to create a Prisma layer - it bundles both
   * PrismaClient and Prisma service together.
   *
   * Pass options directly - the signature matches PrismaClient's constructor.
   * Prisma 6: all options are optional
   * Prisma 7: requires either \`adapter\` or \`accelerateUrl\`
   *
   * @example
   * // Prisma 6
   * const MainLayer = Prisma.layer({ datasourceUrl: process.env.DATABASE_URL })
   *
   * // Prisma 7 with adapter
   * const MainLayer = Prisma.layer({ adapter: myAdapter })
   *
   * // With transaction options
   * const MainLayer = Prisma.layer({
   *   adapter: myAdapter,
   *   transactionOptions: { isolationLevel: "Serializable" }
   * })
   *
   * // Use it
   * Effect.runPromise(program.pipe(Effect.provide(MainLayer)))
   */
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.merge(PrismaClient.layer(...args), Prisma.Default)

  /**
   * Create a complete Prisma layer where PrismaClient options are computed via an Effect.
   * This is useful when you need to fetch configuration or create adapters using Effect.
   *
   * @example
   * // Get config from a service
   * const MainLayer = Prisma.layerEffect(
   *   Effect.gen(function* () {
   *     const config = yield* ConfigService
   *     return { adapter: createAdapter(config.databaseUrl) }
   *   })
   * )
   *
   * // With transaction options
   * const MainLayer = Prisma.layerEffect(
   *   Effect.gen(function* () {
   *     return {
   *       adapter: myAdapter,
   *       transactionOptions: { isolationLevel: "Serializable" }
   *     }
   *   })
   * )
   */
  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.merge(PrismaClient.layerEffect(optionsEffect), Prisma.Default)

}

// ============================================================================
// Deprecated aliases for backward compatibility
// ============================================================================

/**
 * @deprecated Use \`PrismaClient\` instead. Will be removed in next major version.
 */
export const PrismaClientService = PrismaClient

/**
 * @deprecated Use \`Prisma\` instead. Will be removed in next major version.
 */
export const PrismaService = Prisma

/**
 * @deprecated Use \`PrismaClient.layer()\` instead. Will be removed in next major version.
 */
export const makePrismaLayer = PrismaClient.layer

/**
 * @deprecated Use \`PrismaClient.layerEffect()\` instead. Will be removed in next major version.
 */
export const makePrismaLayerEffect = PrismaClient.layerEffect


`;
}

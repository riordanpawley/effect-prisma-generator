// This file was generated by prisma-effect-generator, do not edit manually.

import { Context, Data, Effect, Layer } from "effect"
import { Service } from "effect/Effect"
import { type Prisma, PrismaClient } from "@prisma/client"
import { type EffectPrismaService } from "./types.js"

export class PrismaClientService extends Context.Tag("PrismaClientService")<
  PrismaClientService,
  {
    tx: PrismaClient | Prisma.TransactionClient
    client: PrismaClient
  }
>() {}

export const LivePrismaLayer = Layer.effect(
  PrismaClientService,
  Effect.sync(() => {
    const prisma = new PrismaClient()
    return {
      // The `tx` property (transaction) can be shared and overridden,
      // but the `client` property must always be a PrismaClient instance.
      tx: prisma,
      client: prisma
    }
  })
)

export class PrismaError extends Data.TaggedError("PrismaError")<{
  error: unknown
  operation: string
  model: string
}> {}

export class PrismaService extends Service<PrismaService>()("PrismaService", {
  effect: Effect.gen(function* () {
    const { tx: client } = yield* PrismaClientService
    return {
      
    $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.tryPromise({
        try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
        catch: (error) =>
          new PrismaError({
            error,
            operation: "$executeRaw",
            model: "Prisma"
          })
      }),

    $executeRawUnsafe: (query: string, ...values: any[]) =>
      Effect.tryPromise({
        try: () => client.$executeRawUnsafe(query, ...values),
        catch: (error) =>
          new PrismaError({
            error,
            operation: "$executeRawUnsafe",
            model: "Prisma"
          })
      }),

    $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.tryPromise({
        try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)),
        catch: (error) =>
          new PrismaError({
            error,
            operation: "$queryRaw",
            model: "Prisma"
          })
      }),

    $queryRawUnsafe: (query: string, ...values: any[]) =>
      Effect.tryPromise({
        try: () => client.$queryRawUnsafe(query, ...values),
        catch: (error) =>
          new PrismaError({
            error,
            operation: "$queryRawUnsafe",
            model: "Prisma"
          })
      }),

          user: {
      // Find operations
      findMany: (args?: Prisma.UserFindManyArgs) =>
        Effect.tryPromise({
          try: () => client.user.findMany(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findMany",
              model: "User"
            })
        }),

      findUnique: (args: Prisma.UserFindUniqueArgs) =>
        Effect.tryPromise({
          try: () => client.user.findUnique(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findUnique",
              model: "User"
            })
        }),

      findFirst: (args?: Prisma.UserFindFirstArgs) =>
        Effect.tryPromise({
          try: () => client.user.findFirst(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findFirst",
              model: "User"
            })
        }),

      findUniqueOrThrow: (args: Prisma.UserFindUniqueOrThrowArgs) =>
        Effect.tryPromise({
          try: () => client.user.findUniqueOrThrow(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findUniqueOrThrow",
              model: "User"
            })
        }),

      findFirstOrThrow: (args?: Prisma.UserFindFirstOrThrowArgs) =>
        Effect.tryPromise({
          try: () => client.user.findFirstOrThrow(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findFirstOrThrow",
              model: "User"
            })
        }),

      // Create operations
      create: (args: Prisma.UserCreateArgs) =>
        Effect.tryPromise({
          try: () => client.user.create(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "create",
              model: "User"
            })
        }),

      createMany: (args: Prisma.UserCreateManyArgs) =>
        Effect.tryPromise({
          try: () => client.user.createMany(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "createMany",
              model: "User"
            })
        }),

      createManyAndReturn: (args: Prisma.UserCreateManyAndReturnArgs) =>
        Effect.tryPromise({
          try: () => client.user.createManyAndReturn(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "createManyAndReturn",
              model: "User"
            })
        }),

      // Update operations
      update: (args: Prisma.UserUpdateArgs) =>
        Effect.tryPromise({
          try: () => client.user.update(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "update",
              model: "User"
            })
        }),

      updateMany: (args: Prisma.UserUpdateManyArgs) =>
        Effect.tryPromise({
          try: () => client.user.updateMany(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "updateMany",
              model: "User"
            })
        }),

      upsert: (args: Prisma.UserUpsertArgs) =>
        Effect.tryPromise({
          try: () => client.user.upsert(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "upsert",
              model: "User"
            })
        }),

      // Delete operations
      delete: (args: Prisma.UserDeleteArgs) =>
        Effect.tryPromise({
          try: () => client.user.delete(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "delete",
              model: "User"
            })
        }),

      deleteMany: (args?: Prisma.UserDeleteManyArgs) =>
        Effect.tryPromise({
          try: () => client.user.deleteMany(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "deleteMany",
              model: "User"
            })
        }),

      // Aggregation operations
      count: (args?: Prisma.UserCountArgs) =>
        Effect.tryPromise({
          try: () => client.user.count(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "count",
              model: "User"
            })
        }),

      aggregate: (args: Prisma.UserAggregateArgs) =>
        Effect.tryPromise({
          try: () => client.user.aggregate(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "aggregate",
              model: "User"
            })
        }),

      groupBy: <T extends Prisma.UserGroupByArgs>(args: T) =>
        Effect.tryPromise({
          try: () => client.user.groupBy(args as any),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "groupBy",
              model: "User"
            })
        })
    }
    } as unknown as EffectPrismaService
  })
}) {}

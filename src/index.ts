#!/usr/bin/env node
import type { GeneratorOptions } from "@prisma/generator";
import { DMMF, generatorHandler } from "@prisma/generator-helper";
import fs from "fs/promises";
import path from "path";

const header = `// This file was generated by prisma-effect-generator, do not edit manually.\n`;

// Utility function to convert PascalCase to camelCase
function toCamelCase(str: string) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

generatorHandler({
  onManifest() {
    return {
      defaultOutput: "./generated/effect.ts",
      prettyName: "Prisma Effect Generator",
    };
  },

  async onGenerate(options: GeneratorOptions) {
    const models = options.dmmf.datamodel.models;
    const outputPath = options.generator.output?.value;
    const clientImportPath = options.generator.config.clientImportPath;

    if (!outputPath) {
      throw new Error("effect-prisma-generator: No outputPath specified");
    }
    if (Array.isArray(clientImportPath)) {
      throw new Error("effect-prisma-generator: clientImportPath must be a string. Array given.");
    }
    if (typeof clientImportPath !== "string") {
      throw new Error("effect-prisma-generator: No clientImportPath specified");
    }
    if (!outputPath.toLowerCase().endsWith(".ts")) {
      throw new Error("effect-prisma-generator: outputPath must be a ts file");
    }

    const outputDir = path.dirname(outputPath);
    await fs.mkdir(outputDir, { recursive: true });

    await generateUnifiedService([...models], outputPath, clientImportPath);
  },
});

function generateRawSqlOperations() {
  return `
    $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.flatMap(clientOrTx(client), client =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
          catch: (error) => mapError(error, "$executeRaw", "Prisma")
        }),
      ),

    $executeRawUnsafe: (query: string, ...values: any[]) =>
      Effect.flatMap(clientOrTx(client), client =>
        Effect.tryPromise({
          try: () => client.$executeRawUnsafe(query, ...values),
          catch: (error) => mapError(error, "$executeRawUnsafe", "Prisma")
        }),
      ),

    $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.flatMap(clientOrTx(client), client =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)),
          catch: (error) => mapError(error, "$queryRaw", "Prisma")
        }),
      ),

    $queryRawUnsafe: (query: string, ...values: any[]) =>
      Effect.flatMap(clientOrTx(client), client =>
        Effect.tryPromise({
          try: () => client.$queryRawUnsafe(query, ...values),
          catch: (error) => mapError(error, "$queryRawUnsafe", "Prisma")
        }),
      ),`;
}

function generateModelOperations(models: DMMF.Model[]) {
  return models
    .map((model) => {
      const modelName = model.name;
      const modelNameCamel = toCamelCase(modelName);

      return `    ${modelNameCamel}: {
      findUnique: <T extends Prisma.${modelName}FindUniqueArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}FindUniqueArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUnique(args),
            catch: (error) => mapFindError(error, "findUnique", "${modelName}")
          }),
        ),

      findUniqueOrThrow: <T extends Prisma.${modelName}FindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}FindUniqueOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUniqueOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findUniqueOrThrow", "${modelName}")
          }),
        ),

      findFirst: <T extends Prisma.${modelName}FindFirstArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}FindFirstArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirst(args),
            catch: (error) => mapFindError(error, "findFirst", "${modelName}")
          }),
        ),

      findFirstOrThrow: <T extends Prisma.${modelName}FindFirstOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}FindFirstOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirstOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findFirstOrThrow", "${modelName}")
          }),
        ),

      findMany: <T extends Prisma.${modelName}FindManyArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}FindManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findMany(args),
            catch: (error) => mapFindError(error, "findMany", "${modelName}")
          }),
        ),

      create: <T extends Prisma.${modelName}CreateArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}CreateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.create(args),
            catch: (error) => mapCreateError(error, "create", "${modelName}")
          }),
        ),

      createMany: <T extends Prisma.${modelName}CreateManyArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}CreateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createMany(args),
            catch: (error) => mapCreateError(error, "createMany", "${modelName}")
          }),
        ),

      createManyAndReturn: <T extends Prisma.${modelName}CreateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}CreateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createManyAndReturn(args),
            catch: (error) => mapCreateError(error, "createManyAndReturn", "${modelName}")
          }),
        ),

      delete: <T extends Prisma.${modelName}DeleteArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}DeleteArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.delete(args),
            catch: (error) => mapDeleteError(error, "delete", "${modelName}")
          }),
        ),

      update: <T extends Prisma.${modelName}UpdateArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}UpdateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.update(args),
            catch: (error) => mapUpdateError(error, "update", "${modelName}")
          }),
        ),

      deleteMany: <T extends Prisma.${modelName}DeleteManyArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}DeleteManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.deleteMany(args),
            catch: (error) => mapDeleteManyError(error, "deleteMany", "${modelName}")
          }),
        ),

      updateMany: <T extends Prisma.${modelName}UpdateManyArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}UpdateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateMany(args),
            catch: (error) => mapUpdateManyError(error, "updateMany", "${modelName}")
          }),
        ),

      updateManyAndReturn: <T extends Prisma.${modelName}UpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}UpdateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateManyAndReturn(args),
            catch: (error) => mapUpdateManyError(error, "updateManyAndReturn", "${modelName}")
          }),
        ),

      upsert: <T extends Prisma.${modelName}UpsertArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}UpsertArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.upsert(args),
            catch: (error) => mapCreateError(error, "upsert", "${modelName}")
          }),
        ),

      // Aggregation operations
      count: <T extends Prisma.${modelName}CountArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}CountArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.count(args),
            catch: (error) => mapFindError(error, "count", "${modelName}")
          }),
        ),

      aggregate: <T extends Prisma.${modelName}AggregateArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}AggregateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.aggregate(args),
            catch: (error) => mapFindError(error, "aggregate", "${modelName}")
          }),
        ),

      groupBy: <T extends Prisma.${modelName}GroupByArgs>(args: Prisma.SelectSubset<T, Prisma.${modelName}GroupByArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.groupBy(args as any),
            catch: (error) => mapFindError(error, "groupBy", "${modelName}")
          }),
        ),
    }`;
    })
    .join(",\n\n");
}

async function generateUnifiedService(
  models: DMMF.Model[],
  outputPath: string,
  clientImportPath: string,
) {
  const rawSqlOperations = generateRawSqlOperations();
  const modelOperations = generateModelOperations(models);

  const serviceContent = `${header}
import { Cause, Context, Data, Effect, Exit, Option, Runtime } from "effect"
import { Service } from "effect/Effect"
import { Prisma, PrismaClient } from "${clientImportPath}"

export class PrismaClientService extends Context.Tag("PrismaClientService")<
  PrismaClientService,
  PrismaClient
>() {}

export class PrismaTransactionClientService extends Context.Tag("PrismaTransactionClientService")<
  PrismaTransactionClientService,
  Prisma.TransactionClient
>() {}

export class PrismaUniqueConstraintError extends Data.TaggedError("PrismaUniqueConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError("PrismaForeignKeyConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRecordNotFoundError extends Data.TaggedError("PrismaRecordNotFoundError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelationViolationError extends Data.TaggedError("PrismaRelationViolationError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelatedRecordNotFoundError extends Data.TaggedError("PrismaRelatedRecordNotFoundError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaTransactionConflictError extends Data.TaggedError("PrismaTransactionConflictError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueTooLongError extends Data.TaggedError("PrismaValueTooLongError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueOutOfRangeError extends Data.TaggedError("PrismaValueOutOfRangeError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaDbConstraintError extends Data.TaggedError("PrismaDbConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaConnectionError extends Data.TaggedError("PrismaConnectionError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaMissingRequiredValueError extends Data.TaggedError("PrismaMissingRequiredValueError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaInputValidationError extends Data.TaggedError("PrismaInputValidationError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export type PrismaCreateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaDeleteError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaFindOrThrowError =
  | PrismaConnectionError
  | PrismaRecordNotFoundError

export type PrismaFindError =
  | PrismaConnectionError

export type PrismaDeleteManyError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateManyError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

// Generic mapper for raw operations and fallback
const mapError = (error: unknown, operation: string, model: string): PrismaError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  // Unknown errors are not handled and will be treated as defects
  throw error;
}

// Specific mappers to narrow error types per operation

// Create, Upsert
const mapCreateError = (error: unknown, operation: string, model: string): PrismaCreateError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Update
const mapUpdateError = (error: unknown, operation: string, model: string): PrismaUpdateError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Delete
const mapDeleteError = (error: unknown, operation: string, model: string): PrismaDeleteError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// FindOrThrow
const mapFindOrThrowError = (error: unknown, operation: string, model: string): PrismaFindOrThrowError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Find
const mapFindError = (error: unknown, operation: string, model: string): PrismaFindError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
    }
  }
  throw error;
}

// DeleteMany
const mapDeleteManyError = (error: unknown, operation: string, model: string): PrismaDeleteManyError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// UpdateMany
const mapUpdateManyError = (error: unknown, operation: string, model: string): PrismaUpdateManyError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

const clientOrTx = (client: PrismaClient) => Effect.map(
  Effect.serviceOption(PrismaTransactionClientService),
  Option.getOrElse(() => client),
);

export class PrismaService extends Service<PrismaService>()("PrismaService", {
  effect: Effect.gen(function* () {
    const client = yield* PrismaClientService;
    return {
      $transaction: <A, E, R>(
        effect: Effect.Effect<A, E, R>,
        options?: {
          maxWait?: number
          timeout?: number
          isolationLevel?: Prisma.TransactionIsolationLevel
        }
      ) =>
        Effect.gen(function* () {
          const runtime = yield* Effect.runtime<R>();
          const tx = yield* Effect.serviceOption(PrismaTransactionClientService);
          return yield* Option.match(tx, {
            onSome: (tx) => effect,
            onNone: () =>  Effect.tryPromise({
              try: () =>
                client.$transaction(async (tx) => {
                  const exit = await Runtime.runPromiseExit(runtime)(
                    effect.pipe(Effect.provideService(PrismaTransactionClientService, tx)) as Effect.Effect<A, E, R>,
                  )
                  if (Exit.isSuccess(exit)) {
                    return exit.value
                  }
                  throw Cause.squash(exit.cause)
                }, options),
              catch: (error) => error as E,
            }) as unknown as Effect.Effect<A, E, R>,
          })
        }),
      ${rawSqlOperations}

      ${modelOperations}
    }
  })
}) {}
`;

  await fs.writeFile(outputPath, serviceContent);
}

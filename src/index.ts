#!/usr/bin/env node
import { execSync } from "node:child_process";
import fs from "node:fs/promises";
import path from "node:path";
import type { DMMF } from "@prisma/client/runtime/library";
import type { GeneratorOptions } from "@prisma/generator";
import { generatorHandler } from "@prisma/generator-helper";

const header = `// This file was generated by prisma-effect-generator, do not edit manually.\n`;

// Utility function to convert PascalCase to camelCase
function toCamelCase(str: string) {
	return str.charAt(0).toLowerCase() + str.slice(1);
}

generatorHandler({
	onManifest() {
		return {
			defaultOutput: "../generated/effect",
			prettyName: "Prisma Effect Generator",
			// No engines required - we only read the DMMF schema
			requiresEngines: [],
		};
	},

	async onGenerate(options: GeneratorOptions) {
		const models = options.dmmf.datamodel.models;
		const outputDir = options.generator.output?.value;
		const schemaDir = path.dirname(options.schemaPath);

		const configPath = options.generator.config.clientImportPath;
		const clientImportPath = Array.isArray(configPath)
			? configPath[0]
			: (configPath ?? "@prisma/client");

		// Custom error configuration: "path/to/module#ErrorClassName"
		// Path is relative to schema.prisma, e.g., "./errors#PrismaError"
		// The module must export:
		//   - The error class (e.g., `export class PrismaError extends ...`)
		//   - A mapper function named `mapPrismaError` with signature:
		//     `(error: unknown, operation: string, model: string) => YourErrorType`
		const errorConfigRaw = options.generator.config.errorImportPath;
		const errorImportPathRaw = Array.isArray(errorConfigRaw)
			? errorConfigRaw[0]
			: errorConfigRaw;

		// Import file extension for generated imports (e.g., "js", "ts", or "" for no extension)
		// Useful for ESM compatibility where imports need explicit extensions
		const importExtConfigRaw = options.generator.config.importFileExtension;
		const importFileExtension = Array.isArray(importExtConfigRaw)
			? importExtConfigRaw[0]
			: (importExtConfigRaw ?? "");

		// Telemetry configuration: enable Effect.fn tracing for all operations
		// Set to "true" to wrap operations with Effect.fn (adds operation names to traces)
		// Set to "false" to use Effect.fnUntraced (no telemetry overhead)
		const telemetryConfigRaw = options.generator.config.enableTelemetry;
		const enableTelemetry = Array.isArray(telemetryConfigRaw)
			? telemetryConfigRaw[0] === "true"
			: telemetryConfigRaw === "true";

		if (!outputDir) {
			throw new Error("No output directory specified");
		}

		// Helper to add file extension to a path if configured
		const addExtension = (filePath: string): string => {
			if (!importFileExtension) return filePath;
			// Don't add extension if path already has one
			const ext = path.extname(filePath);
			if (ext) return filePath;
			return `${filePath}.${importFileExtension}`;
		};

		// Convert errorImportPath from schema-relative to output-relative
		let errorImportPath: string | undefined;
		if (errorImportPathRaw) {
			const [modulePath, className] = errorImportPathRaw.split("#");
			if (!modulePath || !className) {
				throw new Error(
					`Invalid errorImportPath format: "${errorImportPathRaw}". Expected "path/to/module#ErrorClassName"`,
				);
			}

			// If it's a relative path, convert from schema-relative to output-relative
			if (modulePath.startsWith(".")) {
				const absoluteErrorPath = path.resolve(schemaDir, modulePath);
				const relativeToOutput = path.relative(outputDir, absoluteErrorPath);
				// Ensure it starts with ./ or ../
				const normalizedPath = relativeToOutput.startsWith(".")
					? relativeToOutput
					: `./${relativeToOutput}`;
				// Add file extension if configured
				const pathWithExtension = addExtension(normalizedPath);
				errorImportPath = `${pathWithExtension}#${className}`;
			} else {
				// Package import (e.g., "@myorg/errors#PrismaError"), use as-is
				errorImportPath = errorImportPathRaw;
			}
		}

		// Clean output directory
		await fs.rm(outputDir, { recursive: true, force: true });
		await fs.mkdir(outputDir, { recursive: true });

		// Generate unified index file with PrismaService
		await generateUnifiedService(
			[...models],
			outputDir,
			clientImportPath,
			errorImportPath,
			enableTelemetry,
		);
	},
});

type CustomErrorConfig = { path: string; className: string } | null;

function generateRawSqlOperations(
	customError: CustomErrorConfig,
	enableTelemetry: boolean,
) {
	// With custom error, use mapError which maps to user's error type
	// Without custom error, use mapError which maps to PrismaError union
	const errorType = customError ? customError.className : "PrismaError";

	const wrapTelemetry = (name: string, generatorFn: string) =>
		enableTelemetry
			? `Effect.fn("${name}")(${generatorFn})`
			: `Effect.fnUntraced(${generatorFn})`;

	return `
    $executeRaw: ${wrapTelemetry(
			"Prisma.$executeRaw",
			`function* (args) {
      const actualClient = yield* clientOrTx(client);
      return yield* Effect.tryPromise<any, ${errorType}>({
        try: () => (Array.isArray(args) ? actualClient.$executeRaw(args[0], ...args.slice(1)) : actualClient.$executeRaw(args)) as any,
        catch: (error) => mapError(error, "$executeRaw", "Prisma")
      });
    }`,
		)},

    $executeRawUnsafe: ${wrapTelemetry(
			"Prisma.$executeRawUnsafe",
			`function* (query, ...values) {
      const actualClient = yield* clientOrTx(client);
      return yield* Effect.tryPromise<any, ${errorType}>({
        try: () => actualClient.$executeRawUnsafe(query, ...values) as any,
        catch: (error) => mapError(error, "$executeRawUnsafe", "Prisma")
      });
    }`,
		)},

    $queryRaw: ${wrapTelemetry(
			"Prisma.$queryRaw",
			`function* (args) {
      const actualClient = yield* clientOrTx(client);
      return yield* Effect.tryPromise<any, ${errorType}>({
        try: () => (Array.isArray(args) ? actualClient.$queryRaw(args[0], ...args.slice(1)) : actualClient.$queryRaw(args)) as any,
        catch: (error) => mapError(error, "$queryRaw", "Prisma")
      });
    }`,
		)},

    $queryRawUnsafe: ${wrapTelemetry(
			"Prisma.$queryRawUnsafe",
			`function* (query, ...values) {
      const actualClient = yield* clientOrTx(client);
      return yield* Effect.tryPromise<any, ${errorType}>({
        try: () => actualClient.$queryRawUnsafe(query, ...values) as any,
        catch: (error) => mapError(error, "$queryRawUnsafe", "Prisma")
      });
    }`,
		)},`;
}

/**
 * Generate type aliases for a model to reduce redundant type computation.
 * TypeScript performance is significantly improved when complex types are
 * computed once and reused via aliases rather than inline.
 */
function generateModelTypeAliases(models: DMMF.Model[]): string {
	return models
		.map((model) => {
			const modelName = model.name;
			const modelNameCamel = toCamelCase(modelName);

			// Operations that need Args/Result type aliases
			const operations = [
				"findUnique",
				"findUniqueOrThrow",
				"findFirst",
				"findFirstOrThrow",
				"findMany",
				"create",
				"createMany",
				"createManyAndReturn",
				"delete",
				"update",
				"deleteMany",
				"updateMany",
				"updateManyAndReturn",
				"upsert",
				"count",
				"aggregate",
				"groupBy",
			];

			const argsAliases = operations
				.map(
					(op) =>
						`type ${modelName}${capitalize(op)}Args = PrismaNamespace.Args<BasePrismaClient['${modelNameCamel}'], '${op}'>`,
				)
				.join("\n");

			return argsAliases;
		})
		.join("\n\n");
}

/**
 * Generate the IPrismaService interface that defines the contract for all Prisma operations.
 * This interface is used to type-check the service implementation and provides explicit types.
 */
function generatePrismaInterface(
	models: DMMF.Model[],
	customError: CustomErrorConfig,
): string {
	const errorType = customError ? customError.className : "PrismaError";

	// Generate model operation interfaces
	const modelInterfaces = models
		.map((model) => {
			const modelName = model.name;
			const modelNameCamel = toCamelCase(modelName);
			const delegate = `BasePrismaClient['${modelNameCamel}']`;

			// Helper to get Args type alias
			const argsType = (op: string) => `${modelName}${capitalize(op)}Args`;

			// Helper for error types based on operation
			const errorTypeFor = (op: string) => {
				if (customError) return customError.className;
				// Map operations to their specific error types
				if (["findUniqueOrThrow", "findFirstOrThrow"].includes(op)) {
					return "PrismaFindOrThrowError";
				} else if (
					[
						"findUnique",
						"findFirst",
						"findMany",
						"count",
						"aggregate",
						"groupBy",
					].includes(op)
				) {
					return "PrismaFindError";
				} else if (
					["create", "createMany", "createManyAndReturn"].includes(op)
				) {
					return "PrismaCreateError";
				} else if (
					["update", "updateMany", "updateManyAndReturn", "upsert"].includes(op)
				) {
					return "PrismaUpdateError";
				} else if (["delete", "deleteMany"].includes(op)) {
					return "PrismaDeleteError";
				}
				return "PrismaError";
			};

			return `  ${modelNameCamel}: {
    findUnique: <A extends ${argsType("findUnique")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'findUnique'> | null, ${errorTypeFor("findUnique")}>

    findUniqueOrThrow: <A extends ${argsType("findUniqueOrThrow")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'findUniqueOrThrow'>, ${errorTypeFor("findUniqueOrThrow")}>

    findFirst: <A extends ${argsType("findFirst")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'findFirst'> | null, ${errorTypeFor("findFirst")}>

    findFirstOrThrow: <A extends ${argsType("findFirstOrThrow")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'findFirstOrThrow'>, ${errorTypeFor("findFirstOrThrow")}>

    findMany: <A extends ${argsType("findMany")}>(
      args?: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'findMany'>, ${errorTypeFor("findMany")}>

    create: <A extends ${argsType("create")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'create'>, ${errorTypeFor("create")}>

    createMany: <A extends ${argsType("createMany")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'createMany'>, ${errorTypeFor("createMany")}>

    createManyAndReturn: <A extends ${argsType("createManyAndReturn")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'createManyAndReturn'>, ${errorTypeFor("createManyAndReturn")}>

    delete: <A extends ${argsType("delete")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'delete'>, ${errorTypeFor("delete")}>

    update: <A extends ${argsType("update")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'update'>, ${errorTypeFor("update")}>

    deleteMany: <A extends ${argsType("deleteMany")}>(
      args?: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'deleteMany'>, ${errorTypeFor("deleteMany")}>

    updateMany: <A extends ${argsType("updateMany")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'updateMany'>, ${errorTypeFor("updateMany")}>

    updateManyAndReturn: <A extends ${argsType("updateManyAndReturn")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'updateManyAndReturn'>, ${errorTypeFor("updateManyAndReturn")}>

    upsert: <A extends ${argsType("upsert")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'upsert'>, ${errorTypeFor("upsert")}>

    count: <A extends ${argsType("count")}>(
      args?: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'count'>, ${errorTypeFor("count")}>

    aggregate: <A extends ${argsType("aggregate")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'aggregate'>, ${errorTypeFor("aggregate")}>

    groupBy: <A extends ${argsType("groupBy")}>(
      args: A
    ) => Effect.Effect<PrismaNamespace.Result<${delegate}, A, 'groupBy'>, ${errorTypeFor("groupBy")}>
  }`;
		})
		.join("\n\n");

	return `/**
 * Interface defining all Prisma operations with explicit types.
 * This provides a type contract that the service implementation must satisfy.
 */
export interface IPrismaService {
  client: BasePrismaClient
  // Transaction operations
  $transaction: <R, E, A>(
    effect: Effect.Effect<A, E, R>
  ) => Effect.Effect<A, E | ${errorType}, Exclude<R, PrismaTransactionClientService>>

  $transactionWith: <R, E, A>(
    effect: Effect.Effect<A, E, R>,
    options: TransactionOptions
  ) => Effect.Effect<A, E | ${errorType}, R>

  $isolatedTransaction: <R, E, A>(
    effect: Effect.Effect<A, E, R>
  ) => Effect.Effect<A, E | ${errorType}, R>

  $isolatedTransactionWith: <R, E, A>(
    effect: Effect.Effect<A, E, R>,
    options: TransactionOptions
  ) => Effect.Effect<A, E | ${errorType}, R>

  // Raw SQL operations
  $executeRaw: (
    args: PrismaNamespace.Sql | [PrismaNamespace.Sql, ...any[]]
  ) => Effect.Effect<number, ${errorType}>

  $executeRawUnsafe: (
    query: string,
    ...values: any[]
  ) => Effect.Effect<number, ${errorType}>

  $queryRaw: <T = unknown>(
    args: PrismaNamespace.Sql | [PrismaNamespace.Sql, ...any[]]
  ) => Effect.Effect<T, ${errorType}>

  $queryRawUnsafe: <T = unknown>(
    query: string,
    ...values: any[]
  ) => Effect.Effect<T, ${errorType}>

  // Model operations
${modelInterfaces}
}
`;
}

function capitalize(str: string): string {
	return str.charAt(0).toUpperCase() + str.slice(1);
}

function generateModelOperations(
	models: DMMF.Model[],
	customError: CustomErrorConfig,
	enableTelemetry: boolean,
) {
	return models
		.map((model) => {
			const modelName = model.name;
			const modelNameCamel = toCamelCase(modelName);
			// Use pre-computed type alias for delegate
			const _delegate = `BasePrismaClient['${modelNameCamel}']`;

			// Helper to get pre-computed Args type alias
			const _argsType = (op: string) => `${modelName}${capitalize(op)}Args`;

			// Cast Promise results to ensure consistent typing across Prisma versions
			// This handles Prisma 7's GlobalOmitConfig and works fine with Prisma 6 too
			// @deprecated just cast as any now
			const promiseCast = () => {
				return " as any";
			};
			// Aggregate/groupBy use complex internal types that need stronger casts
			// @deprecated just cast as any now
			const strongPromiseCast = () => {
				return " as any";
			};

			// With custom error: all operations use single error type and mapError
			// Without custom error: use per-operation error types and mappers
			const errorType = (opErrorType: string) =>
				customError ? customError.className : opErrorType;
			const mapperFn = (defaultMapper: string) =>
				customError ? "mapError" : defaultMapper;

			// Telemetry: wrap operations with Effect.fn or Effect.fnUntraced
			const wrapTelemetry = (name: string, generatorFn: string) =>
				enableTelemetry
					? `Effect.fn("${name}")(${generatorFn})`
					: `Effect.fnUntraced(${generatorFn})`;

			// Implementation without explicit types - the IPrismaService interface provides all type checking
			return `    ${modelNameCamel}: {
      findUnique: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.findUnique`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaFindError")}>({
          try: () => actualClient.${modelNameCamel}.findUnique(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapFindError")}(error, "findUnique", "${modelName}")
        });
      }`,
			)},

      findUniqueOrThrow: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.findUniqueOrThrow`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaFindOrThrowError")}>({
          try: () => actualClient.${modelNameCamel}.findUniqueOrThrow(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapFindOrThrowError")}(error, "findUniqueOrThrow", "${modelName}")
        });
      }`,
			)},

      findFirst: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.findFirst`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaFindError")}>({
          try: () => actualClient.${modelNameCamel}.findFirst(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapFindError")}(error, "findFirst", "${modelName}")
        });
      }`,
			)},

      findFirstOrThrow: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.findFirstOrThrow`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaFindOrThrowError")}>({
          try: () => actualClient.${modelNameCamel}.findFirstOrThrow(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapFindOrThrowError")}(error, "findFirstOrThrow", "${modelName}")
        });
      }`,
			)},

      findMany: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.findMany`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaFindError")}>({
          try: () => actualClient.${modelNameCamel}.findMany(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapFindError")}(error, "findMany", "${modelName}")
        });
      }`,
			)},

      create: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.create`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaCreateError")}>({
          try: () => actualClient.${modelNameCamel}.create(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapCreateError")}(error, "create", "${modelName}")
        });
      }`,
			)},

      createMany: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.createMany`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaCreateError")}>({
          try: () => actualClient.${modelNameCamel}.createMany(args as any),
          catch: (error) => ${mapperFn("mapCreateError")}(error, "createMany", "${modelName}")
        });
      }`,
			)},

      createManyAndReturn: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.createManyAndReturn`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaCreateError")}>({
          try: () => actualClient.${modelNameCamel}.createManyAndReturn(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapCreateError")}(error, "createManyAndReturn", "${modelName}")
        });
      }`,
			)},

      delete: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.delete`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaDeleteError")}>({
          try: () => actualClient.${modelNameCamel}.delete(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapDeleteError")}(error, "delete", "${modelName}")
        });
      }`,
			)},

      update: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.update`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaUpdateError")}>({
          try: () => actualClient.${modelNameCamel}.update(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapUpdateError")}(error, "update", "${modelName}")
        });
      }`,
			)},

      deleteMany: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.deleteMany`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaDeleteManyError")}>({
          try: () => actualClient.${modelNameCamel}.deleteMany(args as any),
          catch: (error) => ${mapperFn("mapDeleteManyError")}(error, "deleteMany", "${modelName}")
        });
      }`,
			)},

      updateMany: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.updateMany`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaUpdateManyError")}>({
          try: () => actualClient.${modelNameCamel}.updateMany(args as any),
          catch: (error) => ${mapperFn("mapUpdateManyError")}(error, "updateMany", "${modelName}")
        });
      }`,
			)},

      updateManyAndReturn: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.updateManyAndReturn`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaUpdateManyError")}>({
          try: () => actualClient.${modelNameCamel}.updateManyAndReturn(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapUpdateManyError")}(error, "updateManyAndReturn", "${modelName}")
        });
      }`,
			)},

      upsert: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.upsert`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaCreateError")}>({
          try: () => actualClient.${modelNameCamel}.upsert(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapCreateError")}(error, "upsert", "${modelName}")
        });
      }`,
			)},

      // Aggregation operations
      count: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.count`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaFindError")}>({
          try: () => actualClient.${modelNameCamel}.count(args as any)${promiseCast()},
          catch: (error) => ${mapperFn("mapFindError")}(error, "count", "${modelName}")
        });
      }`,
			)},

      aggregate: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.aggregate`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaFindError")}>({
          try: () => actualClient.${modelNameCamel}.aggregate(args as any)${strongPromiseCast()},
          catch: (error) => ${mapperFn("mapFindError")}(error, "aggregate", "${modelName}")
        });
      }`,
			)},

      groupBy: ${wrapTelemetry(
				`Prisma.${modelNameCamel}.groupBy`,
				`function* (args) {
        const actualClient = yield* clientOrTx(client);
        return yield* Effect.tryPromise<any, ${errorType("PrismaFindError")}>({
          try: () => actualClient.${modelNameCamel}.groupBy(args as any)${strongPromiseCast()},
          catch: (error) => ${mapperFn("mapFindError")}(error, "groupBy", "${modelName}")
        });
      }`,
			)}
    }`;
		})
		.join(",\n\n");
}

// Parse error import path like "./errors#PrismaError" into { path, className }
function parseErrorImportPath(
	errorImportPath: string | undefined,
): { path: string; className: string } | null {
	if (!errorImportPath) return null;
	const [path, className] = errorImportPath.split("#");
	if (!path || !className) {
		throw new Error(
			`Invalid errorImportPath format: "${errorImportPath}". Expected "path/to/module#ErrorClassName"`,
		);
	}
	return { path, className };
}

async function generateUnifiedService(
	models: DMMF.Model[],
	outputDir: string,
	clientImportPath: string,
	errorImportPath: string | undefined,
	enableTelemetry: boolean,
) {
	const customError = parseErrorImportPath(errorImportPath);
	const rawSqlOperations = generateRawSqlOperations(
		customError,
		enableTelemetry,
	);
	const modelTypeAliases = generateModelTypeAliases(models);
	const prismaInterface = generatePrismaInterface(models, customError);
	const modelOperations = generateModelOperations(
		models,
		customError,
		enableTelemetry,
	);

	// Generate different content based on whether custom error is configured
	const serviceContent = customError
		? generateCustomErrorService(
				customError,
				clientImportPath,
				rawSqlOperations,
				modelTypeAliases,
				prismaInterface,
				modelOperations,
				enableTelemetry,
			)
		: generateDefaultErrorService(
				clientImportPath,
				rawSqlOperations,
				modelTypeAliases,
				prismaInterface,
				modelOperations,
				enableTelemetry,
			);

	const outputPath = path.join(outputDir, "index.ts");
	await fs.writeFile(outputPath, serviceContent);

	// Format the generated file with Biome
	try {
		execSync(`npx @biomejs/biome format --write "${outputPath}"`, {
			stdio: "inherit",
			cwd: process.cwd(),
		});
	} catch (error) {
		console.warn("Warning: Failed to format generated code with Biome:", error);
	}
}

/**
 * Generate service with custom user-provided error class.
 * All operations use a single error type and a simple mapError function.
 */
function generateCustomErrorService(
	customError: { path: string; className: string },
	clientImportPath: string,
	rawSqlOperations: string,
	modelTypeAliases: string,
	prismaInterface: string,
	modelOperations: string,
	enableTelemetry: boolean,
): string {
	const _errorType = customError.className;
	return `${header}
import { Context, Effect, Exit, Layer, Option, Scope } from "effect"
import { Prisma as PrismaNamespace, PrismaClient as BasePrismaClient } from "${clientImportPath}"
import { ${customError.className}, mapPrismaError } from "${customError.path}"

// ============================================================================
// Type aliases for model operations (performance optimization)
// These are computed once and reused, reducing TypeScript's type-checking workload
// ============================================================================

${modelTypeAliases}

// Symbol used to identify intentional rollbacks vs actual errors
const ROLLBACK = Symbol.for("prisma.effect.rollback")

// Type for the flat transaction client with commit/rollback control
type FlatTransactionClient = PrismaNamespace.TransactionClient & {
  $commit: () => Promise<void>
  $rollback: () => Promise<void>
}

/** Transaction options for $transaction and $isolatedTransaction */
type TransactionOptions = {
  maxWait?: number
  timeout?: number
  isolationLevel?: PrismaNamespace.TransactionIsolationLevel
}

/**
 * Context tag for the Prisma client instance.
 *
 * Use \`PrismaClient.layer()\` or \`PrismaClient.layerEffect()\` to create a layer.
 *
 * @example
 * // Prisma 6 - all options are optional
 * const layer = PrismaClient.layer({ datasourceUrl: "..." })
 *
 * // Prisma 7 - adapter or accelerateUrl is required
 * const layer = PrismaClient.layer({ adapter: myAdapter })
 *
 * // With transaction options (Prisma uses these as defaults for $transaction)
 * const layer = PrismaClient.layer({
 *   adapter: myAdapter,  // or datasourceUrl for Prisma 6
 *   transactionOptions: { isolationLevel: "Serializable", timeout: 10000 }
 * })
 */
export class PrismaClient extends Context.Tag("PrismaClient")<
  PrismaClient,
  BasePrismaClient
>() {
  /**
   * Create a PrismaClient layer with the given options.
   * The client will be automatically disconnected when the layer scope ends.
   *
   * Pass options directly - the signature matches PrismaClient's constructor.
   * Prisma 6: all options are optional
   * Prisma 7: requires either \`adapter\` or \`accelerateUrl\`
   *
   * @example
   * // Prisma 6
   * const layer = PrismaClient.layer({ datasourceUrl: process.env.DATABASE_URL })
   *
   * // Prisma 7 with adapter
   * const layer = PrismaClient.layer({ adapter: myAdapter })
   *
   * // With transaction options
   * const layer = PrismaClient.layer({
   *   adapter: myAdapter,
   *   transactionOptions: { isolationLevel: "Serializable" }
   * })
   */
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ): Layer.Layer<PrismaClient, never, never> => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const prisma: BasePrismaClient = new BasePrismaClient(...args)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return prisma
    })
  )

  /**
   * Create a PrismaClient layer where options are computed via an Effect.
   * Useful when you need to fetch configuration from environment, config service, or create adapters.
   * The client will be automatically disconnected when the layer scope ends.
   *
   * @example
   * // Get config from a service
   * const layer = PrismaClient.layerEffect(
   *   Effect.gen(function* () {
   *     const config = yield* ConfigService
   *     return { adapter: createAdapter(config.databaseUrl) }
   *   })
   * )
   *
   * // With transaction options
   * const layer = PrismaClient.layerEffect(
   *   Effect.gen(function* () {
   *     return {
   *       adapter: myAdapter,
   *       transactionOptions: { isolationLevel: "Serializable" }
   *     }
   *   })
   * )
   */
  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ): Layer.Layer<PrismaClient, E, Exclude<R, Scope.Scope>> => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const options: ConstructorParameters<typeof BasePrismaClient>[0] = yield* optionsEffect
      const prisma: BasePrismaClient = new BasePrismaClient(options)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return prisma
    })
  )
}

/**
 * Context tag for the transaction client within a transaction scope.
 * This service is only available inside \`$transaction\` calls.
 * Use \`Effect.serviceOption(PrismaTransactionClientService)\` to check if you're in a transaction.
 */
export class PrismaTransactionClientService extends Context.Tag("PrismaTransactionClientService")<
  PrismaTransactionClientService,
  PrismaNamespace.TransactionClient
>() {}

// Re-export the custom error type for convenience
export { ${customError.className} }

// Use the user-provided error mapper
const mapError = mapPrismaError

/**
 * Helper to get the current client - either the transaction client if in a transaction,
 * or the root client if not. Uses Effect.serviceOption to detect transaction context.
 */
const clientOrTx = (client: BasePrismaClient) => Effect.map(
  Effect.serviceOption(PrismaTransactionClientService),
  Option.getOrElse(() => client),
);

/**
 * Like Effect.acquireUseRelease, but allows the release function to fail.
 * Release errors are surfaced in the error channel instead of becoming defects.
 *
 * Key properties:
 * - The release function is always called, even if use fails
 * - The release function is uninterruptible to ensure cleanup completes
 * - Release errors are surfaced in the error channel, not as defects
 */
const acquireUseReleaseWithErrors = <A, E, R, A2, E2, R2, X, E3, R3>(
  acquire: Effect.Effect<A, E, R>,
  use: (a: A) => Effect.Effect<A2, E2, R2>,
  release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, E3, R3>
): Effect.Effect<A2, E | E2 | E3, R | R2 | R3> =>
  Effect.uninterruptibleMask((restore) =>
    Effect.flatMap(acquire, (a) =>
      Effect.flatMap(
        Effect.exit(restore(use(a))),
        (exit) =>
          Effect.flatMap(
            // Make release uninterruptible to ensure cleanup always completes
            Effect.exit(release(a, exit)),
            (releaseExit) => {
              if (Exit.isFailure(releaseExit)) {
                // Release failed - surface the release error
                return releaseExit as any;
              }
              // Release succeeded - return the original use result
              return exit as any;
            }
          )
      )
    )
  );

${prismaInterface}

/**
 * Internal helper to begin a callback-free interactive transaction.
 * Returns a transaction client with $commit and $rollback methods.
 * This allows transactions to run in the same fiber as the parent effect.
 */
const $begin = (
  client: BasePrismaClient,
  options?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: PrismaNamespace.TransactionIsolationLevel
  }
): Effect.Effect<FlatTransactionClient, ${customError.className}> =>
  Effect.async<FlatTransactionClient, ${customError.className}>((resume) => {
    let setTxClient: (txClient: PrismaNamespace.TransactionClient) => void
    let commit: () => void
    let rollback: () => void

    // Promise that resolves when we get the transaction client
    const txClientPromise = new Promise<PrismaNamespace.TransactionClient>((res) => {
      setTxClient = res
    })

    // Promise that controls when the transaction commits/rolls back
    const txPromise = new Promise<void>((_res, _rej) => {
      commit = () => _res(undefined)
      rollback = () => _rej(ROLLBACK)
    })

    // Start the transaction - Prisma will wait on txPromise before committing
    const tx = client.$transaction((txClient) => {
      setTxClient(txClient)
      return txPromise
    }, options).catch((e) => {
      // Swallow intentional rollbacks, rethrow actual errors
      if (e === ROLLBACK) return
      throw e
    })

    // Once we have the transaction client, wrap it with commit/rollback methods
    txClientPromise.then((innerTx) => {
      const proxy = new Proxy(innerTx, {
        get(target, prop) {
          if (prop === "$commit") return () => { commit(); return tx }
          if (prop === "$rollback") return () => { rollback(); return tx }
          return target[prop as keyof typeof target]
        },
      }) as FlatTransactionClient
      resume(Effect.succeed(proxy))
    }).catch((error) => {
      resume(Effect.fail(mapError(error, "$transaction", "Prisma")))
    })
  })

/**
 * The main Prisma service with all database operations.
 * Provides type-safe, effectful access to your Prisma models.
 *
 * @example
 * const program = Effect.gen(function* () {
 *   const prisma = yield* Prisma
 *   const user = yield* prisma.user.create({ data: { name: "Alice" } })
 *   return user
 * })
 *
 * // Run with layer
 * Effect.runPromise(program.pipe(Effect.provide(Prisma.layer({ datasourceUrl: "..." }))))
 */
const makePrismaService = Effect.gen(function* () {
  const client = yield* PrismaClient;

  const prismaService: IPrismaService = {
      client,
      /**
       * Execute an effect within a database transaction.
       * All operations within the effect will be atomic - they either all succeed or all fail.
       *
       * This implementation uses a callback-free transaction pattern that keeps the effect
       * running in the same fiber as the parent, preserving Ref, FiberRef, and Context access.
       *
       * Uses default transaction options from PrismaClient constructor.
       * For custom options, use \`$transactionWith\`.
       *
       * @example
       * const result = yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     const user = yield* prisma.user.create({ data: { name: "Alice" } })
       *     yield* prisma.post.create({ data: { title: "Hello", authorId: user.id } })
       *     return user
       *   })
       * )
       */
      $transaction: ${enableTelemetry ? 'Effect.fn("Prisma.$transaction")' : "Effect.fnUntraced"}(function* (effect) {
          const currentTx = yield* Effect.serviceOption(PrismaTransactionClientService);

          // If already in a transaction, just run the effect
          if (Option.isSome(currentTx)) {
            // have to get this to pass the Exclude type
            return yield* (effect as Effect.Effect<
            Effect.Effect.Success<typeof effect>,
            Effect.Effect.Error<typeof effect>,
            Exclude<
              Effect.Effect.Context<typeof effect>,
              PrismaTransactionClientService
            >
          >);
          }

          // Otherwise, start a new transaction
          return yield* acquireUseReleaseWithErrors(
            // Acquire: begin a new transaction with default options
            $begin(client),

            // Use: run the effect with the transaction client injected
            (txClient) =>
              effect.pipe(
                Effect.provideService(PrismaTransactionClientService, txClient)
              ),

            // Release: commit on success, rollback on failure/interruption
            (txClient, exit) =>
              Exit.isSuccess(exit)
                ? Effect.tryPromise({
                    try: () => txClient.$commit(),
                    catch: (error) => mapError(error, "$commit", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$commit"))
                : Effect.tryPromise({
                    try: () => txClient.$rollback(),
                    catch: (error) => mapError(error, "$rollback", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
          );
        }),

      /**
       * Execute an effect within a database transaction with custom options.
       * All operations within the effect will be atomic - they either all succeed or all fail.
       *
       * This implementation uses a callback-free transaction pattern that keeps the effect
       * running in the same fiber as the parent, preserving Ref, FiberRef, and Context access.
       *
       * Options passed here override any defaults set in PrismaClient constructor.
       *
       * @example
       * // Override default isolation level for this transaction
       * const result = yield* prisma.$transactionWith(
       *   Effect.gen(function* () {
       *     const user = yield* prisma.user.create({ data: { name: "Alice" } })
       *     yield* prisma.post.create({ data: { title: "Hello", authorId: user.id } })
       *     return user
       *   }),
       *   { isolationLevel: "ReadCommitted", timeout: 10000 }
       * )
       */
      $transactionWith: ${enableTelemetry ? 'Effect.fn("Prisma.$transactionWith")' : "Effect.fnUntraced"}(function* (effect, options) {
          const currentTx = yield* Effect.serviceOption(PrismaTransactionClientService);

          // If already in a transaction, just run the effect
          if (Option.isSome(currentTx)) {
            return yield* effect;
          }

          // Otherwise, start a new transaction
          return yield* acquireUseReleaseWithErrors(
            // Acquire: begin a new transaction
            // Prisma merges per-call options with constructor defaults internally
            $begin(client, options),

            // Use: run the effect with the transaction client injected
            (txClient) =>
              effect.pipe(
                Effect.provideService(PrismaTransactionClientService, txClient)
              ),

            // Release: commit on success, rollback on failure/interruption
            (txClient, exit) =>
              Exit.isSuccess(exit)
                ? Effect.tryPromise({
                    try: () => txClient.$commit(),
                    catch: (error) => mapError(error, "$commit", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
                : Effect.tryPromise({
                    try: () => txClient.$rollback(),
                    catch: (error) => mapError(error, "$rollback", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
          );
        }),

      /**
       * Execute an effect in a NEW transaction, even if already inside a transaction.
       * Unlike \`$transaction\`, this always creates a fresh, independent transaction.
       *
       * Use this for operations that should NOT be rolled back with the parent:
       * - Audit logging that must persist even if main operation fails
       * - Saga pattern where each step has independent commit/rollback
       * - Background job queuing that should commit immediately
       *
       * ⚠️ WARNING: The isolated transaction can commit while the parent rolls back,
       * or vice versa. Use carefully to avoid data inconsistencies.
       *
       * Uses default transaction options from PrismaClient constructor.
       * For custom options, use \`$isolatedTransactionWith\`.
       *
       * @example
       * yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     // This audit log commits independently - survives parent rollback
       *     yield* prisma.$isolatedTransaction(
       *       prisma.auditLog.create({ data: { action: "attempt", userId } })
       *     )
       *     // Main operation - if this fails, audit log is still committed
       *     yield* prisma.user.delete({ where: { id: userId } })
       *   })
       * )
       */
      $isolatedTransaction: ${enableTelemetry ? 'Effect.fn("Prisma.$isolatedTransaction")' : "Effect.fnUntraced"}(function* (effect) {
          // Always create a fresh transaction
          return yield* acquireUseReleaseWithErrors(
            $begin(client),
            (txClient) =>
              effect.pipe(
                Effect.provideService(PrismaTransactionClientService, txClient)
              ),
            (txClient, exit) =>
              Exit.isSuccess(exit)
                ? Effect.tryPromise({
                    try: () => txClient.$commit(),
                    catch: (error) => mapError(error, "$commit", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
                : Effect.tryPromise({
                    try: () => txClient.$rollback(),
                    catch: (error) => mapError(error, "$rollback", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
          );
        }),

      /**
       * Execute an effect in a NEW transaction with custom options, even if already inside a transaction.
       * Unlike \`$transaction\`, this always creates a fresh, independent transaction.
       *
       * Use this for operations that should NOT be rolled back with the parent:
       * - Audit logging that must persist even if main operation fails
       * - Saga pattern where each step has independent commit/rollback
       * - Background job queuing that should commit immediately
       *
       * ⚠️ WARNING: The isolated transaction can commit while the parent rolls back,
       * or vice versa. Use carefully to avoid data inconsistencies.
       *
       * Options passed here override any defaults set in PrismaClient constructor.
       *
       * @example
       * yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     // This audit log commits independently with custom isolation level
       *     yield* prisma.$isolatedTransactionWith(
       *       prisma.auditLog.create({ data: { action: "attempt", userId } }),
       *       { isolationLevel: "Serializable" }
       *     )
       *     // Main operation - if this fails, audit log is still committed
       *     yield* prisma.user.delete({ where: { id: userId } })
       *   })
       * )
       */
      $isolatedTransactionWith: ${enableTelemetry ? 'Effect.fn("Prisma.$isolatedTransactionWith")' : "Effect.fnUntraced"}(function* (effect, options) {
          // Always create a fresh transaction
          return yield* acquireUseReleaseWithErrors(
            $begin(client, options),
            (txClient) =>
              effect.pipe(
                Effect.provideService(PrismaTransactionClientService, txClient)
              ),
            (txClient, exit) =>
              Exit.isSuccess(exit)
                ? Effect.tryPromise({
                    try: () => txClient.$commit(),
                    catch: (error) => mapError(error, "$commit", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
                : Effect.tryPromise({
                    try: () => txClient.$rollback(),
                    catch: (error) => mapError(error, "$rollback", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
          );
        }),
      ${rawSqlOperations}

      ${modelOperations}
  };

  return prismaService;
});

export class Prisma extends Context.Tag("Prisma")<Prisma, IPrismaService>() {
  /**
   * Effect that constructs the Prisma service.
   * Used internally by layer constructors.
   */
  static make: Effect.Effect<IPrismaService, never, PrismaClient> = makePrismaService;
  static Default: Layer.Layer<Prisma, never, PrismaClient> = Layer.effect(Prisma, this.make);

  /**
   * Create a complete Prisma layer with the given PrismaClient options.
   * This is the recommended way to create a Prisma layer - it bundles both
   * PrismaClient and Prisma service together.
   *
   * Pass options directly - the signature matches PrismaClient's constructor.
   * Prisma 6: all options are optional
   * Prisma 7: requires either \`adapter\` or \`accelerateUrl\`
   *
   * @example
   * // Prisma 6
   * const MainLayer = Prisma.layer({ datasourceUrl: process.env.DATABASE_URL })
   *
   * // Prisma 7 with adapter
   * const MainLayer = Prisma.layer({ adapter: myAdapter })
   *
   * // With transaction options
   * const MainLayer = Prisma.layer({
   *   adapter: myAdapter,
   *   transactionOptions: { isolationLevel: "Serializable" }
   * })
   *
   * // Use it
   * Effect.runPromise(program.pipe(Effect.provide(MainLayer)))
   */
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ): Layer.Layer<Prisma | PrismaClient, never, never> => this.Default.pipe(
    Layer.provideMerge(PrismaClient.layer(...args))
  );

  /**
   * Create a complete Prisma layer where PrismaClient options are computed via an Effect.
   * This is useful when you need to fetch configuration or create adapters using Effect.
   *
   * @example
   * // Get config from a service
   * const MainLayer = Prisma.layerEffect(
   *   Effect.gen(function* () {
   *     const config = yield* ConfigService
   *     return { adapter: createAdapter(config.databaseUrl) }
   *   })
   * )
   *
   * // With transaction options
   * const MainLayer = Prisma.layerEffect(
   *   Effect.gen(function* () {
   *     return {
   *       adapter: myAdapter,
   *       transactionOptions: { isolationLevel: "Serializable" }
   *     }
   *   })
   * )
   */
  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ): Layer.Layer<Prisma | PrismaClient, E, Exclude<R, Scope.Scope>> => this.Default.pipe(
    Layer.provideMerge(PrismaClient.layerEffect(optionsEffect))
  );
}

`;
}

/**
 * Generate service with default tagged error classes.
 * Operations have per-operation error types for fine-grained error handling.
 */
function generateDefaultErrorService(
	clientImportPath: string,
	rawSqlOperations: string,
	modelTypeAliases: string,
	prismaInterface: string,
	modelOperations: string,
	enableTelemetry: boolean,
): string {
	const _errorType = "PrismaError";
	return `${header}
import { Context, Data, Effect, Exit, Layer, Option, Scope } from "effect"
import { Prisma as PrismaNamespace, PrismaClient as BasePrismaClient } from "${clientImportPath}"

// Create local reference to error class for proper type narrowing
const PrismaClientKnownRequestError = PrismaNamespace.PrismaClientKnownRequestError

// Type guard function to help TypeScript narrow the error type
// This is needed for Prisma 7 which re-exports error classes from external packages
function isPrismaClientKnownRequestError(error: unknown): error is PrismaNamespace.PrismaClientKnownRequestError {
  return error instanceof PrismaClientKnownRequestError
}

// ============================================================================
// Type aliases for model operations (performance optimization)
// These are computed once and reused, reducing TypeScript's type-checking workload
// ============================================================================

${modelTypeAliases}

// Symbol used to identify intentional rollbacks vs actual errors
const ROLLBACK = Symbol.for("prisma.effect.rollback")

// Type for the flat transaction client with commit/rollback control
type FlatTransactionClient = PrismaNamespace.TransactionClient & {
  $commit: () => Promise<void>
  $rollback: () => Promise<void>
}

/** Transaction options for $transaction and $isolatedTransaction */
type TransactionOptions = {
  maxWait?: number
  timeout?: number
  isolationLevel?: PrismaNamespace.TransactionIsolationLevel
}

/**
 * Context tag for the Prisma client instance.
 *
 * Use \`PrismaClient.layer()\` or \`PrismaClient.layerEffect()\` to create a layer.
 *
 * @example
 * // Prisma 6 - all options are optional
 * const layer = PrismaClient.layer({ datasourceUrl: "..." })
 *
 * // Prisma 7 - adapter or accelerateUrl is required
 * const layer = PrismaClient.layer({ adapter: myAdapter })
 *
 * // With transaction options (Prisma uses these as defaults for $transaction)
 * const layer = PrismaClient.layer({
 *   adapter: myAdapter,  // or datasourceUrl for Prisma 6
 *   transactionOptions: { isolationLevel: "Serializable", timeout: 10000 }
 * })
 */
export class PrismaClient extends Context.Tag("PrismaClient")<
  PrismaClient,
  BasePrismaClient
>() {
  /**
   * Create a PrismaClient layer with the given options.
   * The client will be automatically disconnected when the layer scope ends.
   *
   * Pass options directly - the signature matches PrismaClient's constructor.
   * Prisma 6: all options are optional
   * Prisma 7: requires either \`adapter\` or \`accelerateUrl\`
   *
   * @example
   * // Prisma 6
   * const layer = PrismaClient.layer({ datasourceUrl: process.env.DATABASE_URL })
   *
   * // Prisma 7 with adapter
   * const layer = PrismaClient.layer({ adapter: myAdapter })
   *
   * // With transaction options
   * const layer = PrismaClient.layer({
   *   adapter: myAdapter,
   *   transactionOptions: { isolationLevel: "Serializable" }
   * })
   */
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ): Layer.Layer<PrismaClient, never, never> => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const prisma: BasePrismaClient = new BasePrismaClient(...args)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return prisma
    })
  )

  /**
   * Create a PrismaClient layer where options are computed via an Effect.
   * Useful when you need to fetch configuration from environment, config service, or create adapters.
   * The client will be automatically disconnected when the layer scope ends.
   *
   * @example
   * // Get config from a service
   * const layer = PrismaClient.layerEffect(
   *   Effect.gen(function* () {
   *     const config = yield* ConfigService
   *     return { adapter: createAdapter(config.databaseUrl) }
   *   })
   * )
   *
   * // With transaction options
   * const layer = PrismaClient.layerEffect(
   *   Effect.gen(function* () {
   *     return {
   *       adapter: myAdapter,
   *       transactionOptions: { isolationLevel: "Serializable" }
   *     }
   *   })
   * )
   */
  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ): Layer.Layer<PrismaClient, E, Exclude<R, Scope.Scope>> => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const options: ConstructorParameters<typeof BasePrismaClient>[0] = yield* optionsEffect
      const prisma: BasePrismaClient = new BasePrismaClient(options)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return prisma
    })
  )
}

/**
 * Context tag for the transaction client within a transaction scope.
 * This service is only available inside \`$transaction\` calls.
 * Use \`Effect.serviceOption(PrismaTransactionClientService)\` to check if you're in a transaction.
 */
export class PrismaTransactionClientService extends Context.Tag("PrismaTransactionClientService")<
  PrismaTransactionClientService,
  PrismaNamespace.TransactionClient
>() {}

export class PrismaUniqueConstraintError extends Data.TaggedError("PrismaUniqueConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError("PrismaForeignKeyConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRecordNotFoundError extends Data.TaggedError("PrismaRecordNotFoundError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelationViolationError extends Data.TaggedError("PrismaRelationViolationError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelatedRecordNotFoundError extends Data.TaggedError("PrismaRelatedRecordNotFoundError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaTransactionConflictError extends Data.TaggedError("PrismaTransactionConflictError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueTooLongError extends Data.TaggedError("PrismaValueTooLongError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueOutOfRangeError extends Data.TaggedError("PrismaValueOutOfRangeError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaDbConstraintError extends Data.TaggedError("PrismaDbConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaConnectionError extends Data.TaggedError("PrismaConnectionError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaMissingRequiredValueError extends Data.TaggedError("PrismaMissingRequiredValueError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaInputValidationError extends Data.TaggedError("PrismaInputValidationError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export type PrismaCreateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaDeleteError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaFindOrThrowError =
  | PrismaConnectionError
  | PrismaRecordNotFoundError

export type PrismaFindError =
  | PrismaConnectionError

export type PrismaDeleteManyError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateManyError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

// Generic mapper for raw operations and fallback
const mapError = (error: unknown, operation: string, model: string): PrismaError => {
  if (isPrismaClientKnownRequestError(error)) {
    const knownError = error;
    switch (knownError.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  // Unknown errors are not handled and will be treated as defects
  throw error;
}

// Specific mappers to narrow error types per operation

// Create, Upsert
const mapCreateError = (error: unknown, operation: string, model: string): PrismaCreateError => {
  if (isPrismaClientKnownRequestError(error)) {
    const knownError = error;
    switch (knownError.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Update
const mapUpdateError = (error: unknown, operation: string, model: string): PrismaUpdateError => {
  if (isPrismaClientKnownRequestError(error)) {
    const knownError = error;
    switch (knownError.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Delete
const mapDeleteError = (error: unknown, operation: string, model: string): PrismaDeleteError => {
  if (isPrismaClientKnownRequestError(error)) {
    const knownError = error;
    switch (knownError.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// FindOrThrow
const mapFindOrThrowError = (error: unknown, operation: string, model: string): PrismaFindOrThrowError => {
  if (isPrismaClientKnownRequestError(error)) {
    const knownError = error;
    switch (knownError.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Find
const mapFindError = (error: unknown, operation: string, model: string): PrismaFindError => {
  if (isPrismaClientKnownRequestError(error)) {
    const knownError = error;
    switch (knownError.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
    }
  }
  throw error;
}

// DeleteMany
const mapDeleteManyError = (error: unknown, operation: string, model: string): PrismaDeleteManyError => {
  if (isPrismaClientKnownRequestError(error)) {
    const knownError = error;
    switch (knownError.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// UpdateMany
const mapUpdateManyError = (error: unknown, operation: string, model: string): PrismaUpdateManyError => {
  if (isPrismaClientKnownRequestError(error)) {
    const knownError = error;
    switch (knownError.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

/**
 * Helper to get the current client - either the transaction client if in a transaction,
 * or the root client if not. Uses Effect.serviceOption to detect transaction context.
 */
const clientOrTx = (client: BasePrismaClient) => Effect.map(
  Effect.serviceOption(PrismaTransactionClientService),
  Option.getOrElse(() => client),
);

/**
 * Like Effect.acquireUseRelease, but allows the release function to fail.
 * Release errors are surfaced in the error channel instead of becoming defects.
 *
 * Key properties:
 * - The release function is always called, even if use fails
 * - The release function is uninterruptible to ensure cleanup completes
 * - Release errors are surfaced in the error channel, not as defects
 */
const acquireUseReleaseWithErrors = <A, E, R, A2, E2, R2, X, E3, R3>(
  acquire: Effect.Effect<A, E, R>,
  use: (a: A) => Effect.Effect<A2, E2, R2>,
  release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, E3, R3>
): Effect.Effect<A2, E | E2 | E3, R | R2 | R3> =>
  Effect.uninterruptibleMask((restore) =>
    Effect.flatMap(acquire, (a) =>
      Effect.flatMap(
        Effect.exit(restore(use(a))),
        (exit) =>
          Effect.flatMap(
            // Make release uninterruptible to ensure cleanup always completes
            Effect.exit(Effect.uninterruptible(release(a, exit))),
            (releaseExit) => {
              if (Exit.isFailure(releaseExit)) {
                // Release failed - surface the release error
                return releaseExit as any;
              }
              // Release succeeded - return the original use result
              return exit as any;
            }
          )
      )
    )
  );

${prismaInterface}

/**
 * Internal helper to begin a callback-free interactive transaction.
 * Returns a transaction client with $commit and $rollback methods.
 * This allows transactions to run in the same fiber as the parent effect.
 */
const $begin = (
  client: BasePrismaClient,
  options?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: PrismaNamespace.TransactionIsolationLevel
  }
): Effect.Effect<FlatTransactionClient, PrismaError> =>
  Effect.async<FlatTransactionClient, PrismaError>((resume) => {
    let setTxClient: (txClient: PrismaNamespace.TransactionClient) => void
    let commit: () => void
    let rollback: () => void

    // Promise that resolves when we get the transaction client
    const txClientPromise = new Promise<PrismaNamespace.TransactionClient>((res) => {
      setTxClient = res
    })

    // Promise that controls when the transaction commits/rolls back
    const txPromise = new Promise<void>((_res, _rej) => {
      commit = () => _res(undefined)
      rollback = () => _rej(ROLLBACK)
    })

    // Start the transaction - Prisma will wait on txPromise before committing
    const tx = client.$transaction((txClient) => {
      setTxClient(txClient)
      return txPromise
    }, options).catch((e) => {
      // Swallow intentional rollbacks, rethrow actual errors
      if (e === ROLLBACK) return
      throw e
    })

    // Once we have the transaction client, wrap it with commit/rollback methods
    txClientPromise.then((innerTx) => {
      const proxy = new Proxy(innerTx, {
        get(target, prop) {
          if (prop === "$commit") return () => { commit(); return tx }
          if (prop === "$rollback") return () => { rollback(); return tx }
          return target[prop as keyof typeof target]
        },
      }) as FlatTransactionClient
      resume(Effect.succeed(proxy))
    }).catch((error) => {
      resume(Effect.fail(mapError(error, "$transaction", "Prisma")))
    })
  })

/**
 * The main Prisma service with all database operations.
 * Provides type-safe, effectful access to your Prisma models.
 *
 * @example
 * const program = Effect.gen(function* () {
 *   const prisma = yield* Prisma
 *   const user = yield* prisma.user.create({ data: { name: "Alice" } })
 *   return user
 * })
 *
 * // Run with layer
 * Effect.runPromise(program.pipe(Effect.provide(Prisma.layer({ datasourceUrl: "..." }))))
 */
const makePrismaService = Effect.gen(function* () {
  const client = yield* PrismaClient;

  const prismaService: IPrismaService = {
      client,
      /**
       * Execute an effect within a database transaction.
       * All operations within the effect will be atomic - they either all succeed or all fail.
       *
       * This implementation uses a callback-free transaction pattern that keeps the effect
       * running in the same fiber as the parent, preserving Ref, FiberRef, and Context access.
       *
       * Uses default transaction options from PrismaClient constructor.
       * For custom options, use \`$transactionWith\`.
       *
       * @example
       * const result = yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     const user = yield* prisma.user.create({ data: { name: "Alice" } })
       *     yield* prisma.post.create({ data: { title: "Hello", authorId: user.id } })
       *     return user
       *   })
       * )
       */
      $transaction: ${enableTelemetry ? 'Effect.fn("Prisma.$transaction")' : "Effect.fnUntraced"}(function* (effect) {
          const currentTx = yield* Effect.serviceOption(PrismaTransactionClientService);

          // If already in a transaction, just run the effect
          if (Option.isSome(currentTx)) {
            return yield* (effect as Effect.Effect<
            Effect.Effect.Success<typeof effect>,
            Effect.Effect.Error<typeof effect>,
            Exclude<
              Effect.Effect.Context<typeof effect>,
              PrismaTransactionClientService
            >
          >);
          }

          // Otherwise, start a new transaction
          return yield* acquireUseReleaseWithErrors(
            // Acquire: begin a new transaction with default options
            $begin(client),

            // Use: run the effect with the transaction client injected
            (txClient) =>
              effect.pipe(
                Effect.provideService(PrismaTransactionClientService, txClient)
              ),

            // Release: commit on success, rollback on failure/interruption
            (txClient, exit) =>
              Exit.isSuccess(exit)
                ? Effect.tryPromise({
                    try: () => txClient.$commit(),
                    catch: (error) => mapError(error, "$commit", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
                : Effect.tryPromise({
                    try: () => txClient.$rollback(),
                    catch: (error) => mapError(error, "$rollback", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
          );
        }),

      /**
       * Execute an effect within a database transaction with custom options.
       * All operations within the effect will be atomic - they either all succeed or all fail.
       *
       * This implementation uses a callback-free transaction pattern that keeps the effect
       * running in the same fiber as the parent, preserving Ref, FiberRef, and Context access.
       *
       * Options passed here override any defaults set in PrismaClient constructor.
       *
       * @example
       * // Override default isolation level for this transaction
       * const result = yield* prisma.$transactionWith(
       *   Effect.gen(function* () {
       *     const user = yield* prisma.user.create({ data: { name: "Alice" } })
       *     yield* prisma.post.create({ data: { title: "Hello", authorId: user.id } })
       *     return user
       *   }),
       *   { isolationLevel: "ReadCommitted", timeout: 10000 }
       * )
       */
      $transactionWith: ${enableTelemetry ? 'Effect.fn("Prisma.$transactionWith")' : "Effect.fnUntraced"}(function* (effect, options) {
          const currentTx = yield* Effect.serviceOption(PrismaTransactionClientService);

          // If already in a transaction, just run the effect
          if (Option.isSome(currentTx)) {
            return yield* effect;
          }

          // Otherwise, start a new transaction
          return yield* acquireUseReleaseWithErrors(
            // Acquire: begin a new transaction
            // Prisma merges per-call options with constructor defaults internally
            $begin(client, options),

            // Use: run the effect with the transaction client injected
            (txClient) =>
              effect.pipe(
                Effect.provideService(PrismaTransactionClientService, txClient)
              ),

            // Release: commit on success, rollback on failure/interruption
            (txClient, exit) =>
              Exit.isSuccess(exit)
                ? Effect.tryPromise({
                    try: () => txClient.$commit(),
                    catch: (error) => mapError(error, "$commit", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
                : Effect.tryPromise({
                    try: () => txClient.$rollback(),
                    catch: (error) => mapError(error, "$rollback", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
          );
        }),

      /**
       * Execute an effect in a NEW transaction, even if already inside a transaction.
       * Unlike \`$transaction\`, this always creates a fresh, independent transaction.
       *
       * Use this for operations that should NOT be rolled back with the parent:
       * - Audit logging that must persist even if main operation fails
       * - Saga pattern where each step has independent commit/rollback
       * - Background job queuing that should commit immediately
       *
       * ⚠️ WARNING: The isolated transaction can commit while the parent rolls back,
       * or vice versa. Use carefully to avoid data inconsistencies.
       *
       * Uses default transaction options from PrismaClient constructor.
       * For custom options, use \`$isolatedTransactionWith\`.
       *
       * @example
       * yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     // This audit log commits independently - survives parent rollback
       *     yield* prisma.$isolatedTransaction(
       *       prisma.auditLog.create({ data: { action: "attempt", userId } })
       *     )
       *     // Main operation - if this fails, audit log is still committed
       *     yield* prisma.user.delete({ where: { id: userId } })
       *   })
       * )
       */
      $isolatedTransaction: ${enableTelemetry ? 'Effect.fn("Prisma.$isolatedTransaction")' : "Effect.fnUntraced"}(function* (effect) {
          // Always create a fresh transaction
          return yield* acquireUseReleaseWithErrors(
            $begin(client),
            (txClient) =>
              effect.pipe(
                Effect.provideService(PrismaTransactionClientService, txClient)
              ),
            (txClient, exit) =>
              Exit.isSuccess(exit)
                ? Effect.tryPromise({
                    try: () => txClient.$commit(),
                    catch: (error) => mapError(error, "$commit", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
                : Effect.tryPromise({
                    try: () => txClient.$rollback(),
                    catch: (error) => mapError(error, "$rollback", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
          );
        }),

      /**
       * Execute an effect in a NEW transaction with custom options, even if already inside a transaction.
       * Unlike \`$transaction\`, this always creates a fresh, independent transaction.
       *
       * Use this for operations that should NOT be rolled back with the parent:
       * - Audit logging that must persist even if main operation fails
       * - Saga pattern where each step has independent commit/rollback
       * - Background job queuing that should commit immediately
       *
       * ⚠️ WARNING: The isolated transaction can commit while the parent rolls back,
       * or vice versa. Use carefully to avoid data inconsistencies.
       *
       * Options passed here override any defaults set in PrismaClient constructor.
       *
       * @example
       * yield* prisma.$transaction(
       *   Effect.gen(function* () {
       *     // This audit log commits independently with custom isolation level
       *     yield* prisma.$isolatedTransactionWith(
       *       prisma.auditLog.create({ data: { action: "attempt", userId } }),
       *       { isolationLevel: "Serializable" }
       *     )
       *     // Main operation - if this fails, audit log is still committed
       *     yield* prisma.user.delete({ where: { id: userId } })
       *   })
       * )
       */
      $isolatedTransactionWith: ${enableTelemetry ? 'Effect.fn("Prisma.$isolatedTransactionWith")' : "Effect.fnUntraced"}(function* (effect, options) {
          // Always create a fresh transaction
          return yield* acquireUseReleaseWithErrors(
            $begin(client, options),
            (txClient) =>
              effect.pipe(
                Effect.provideService(PrismaTransactionClientService, txClient)
              ),
            (txClient, exit) =>
              Exit.isSuccess(exit)
                ? Effect.tryPromise({
                    try: () => txClient.$commit(),
                    catch: (error) => mapError(error, "$commit", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
                : Effect.tryPromise({
                    try: () => txClient.$rollback(),
                    catch: (error) => mapError(error, "$rollback", "Prisma")
                  }).pipe(Effect.withSpan("txClient.$rollback"))
          );
        }),
      ${rawSqlOperations}

      ${modelOperations}
  };

  return prismaService;
});

export class Prisma extends Context.Tag("Prisma")<Prisma, IPrismaService>() {
  /**
   * Effect that constructs the Prisma service.
   * Used internally by layer constructors.
   */
  static make: Effect.Effect<IPrismaService, never, PrismaClient> = makePrismaService;
  static Default: Layer.Layer<Prisma, never, PrismaClient> = Layer.effect(Prisma, this.make);

  /**
   * Create a complete Prisma layer with the given PrismaClient options.
   * This is the recommended way to create a Prisma layer - it bundles both
   * PrismaClient and Prisma service together.
   *
   * Pass options directly - the signature matches PrismaClient's constructor.
   * Prisma 6: all options are optional
   * Prisma 7: requires either \`adapter\` or \`accelerateUrl\`
   *
   * @example
   * // Prisma 6
   * const MainLayer = Prisma.layer({ datasourceUrl: process.env.DATABASE_URL })
   *
   * // Prisma 7 with adapter
   * const MainLayer = Prisma.layer({ adapter: myAdapter })
   *
   * // With transaction options
   * const MainLayer = Prisma.layer({
   *   adapter: myAdapter,
   *   transactionOptions: { isolationLevel: "Serializable" }
   * })
   *
   * // Use it
   * Effect.runPromise(program.pipe(Effect.provide(MainLayer)))
   */
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ): Layer.Layer<Prisma | PrismaClient, never, never> => this.Default.pipe(
    Layer.provideMerge(PrismaClient.layer(...args))
  );

  /**
   * Create a complete Prisma layer where PrismaClient options are computed via an Effect.
   * This is useful when you need to fetch configuration or create adapters using Effect.
   *
   * @example
   * // Get config from a service
   * const MainLayer = Prisma.layerEffect(
   *   Effect.gen(function* () {
   *     const config = yield* ConfigService
   *     return { adapter: createAdapter(config.databaseUrl) }
   *   })
   * )
   *
   * // With transaction options
   * const MainLayer = Prisma.layerEffect(
   *   Effect.gen(function* () {
   *     return {
   *       adapter: myAdapter,
   *       transactionOptions: { isolationLevel: "Serializable" }
   *     }
   *   })
   * )
   */
  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ): Layer.Layer<Prisma | PrismaClient, E, Exclude<R, Scope.Scope>> => this.Default.pipe(
    Layer.provideMerge(PrismaClient.layerEffect(optionsEffect))
  );
}

`;
}

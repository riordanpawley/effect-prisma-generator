#!/usr/bin/env node
import { DMMF } from "@prisma/client/runtime/library";
import type { GeneratorOptions } from "@prisma/generator";
import { generatorHandler } from "@prisma/generator-helper";
import fs from "node:fs/promises";
import path from "node:path";

const header = `// This file was generated by prisma-effect-generator, do not edit manually.\n`;

// Utility function to convert PascalCase to camelCase
function toCamelCase(str: string) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

generatorHandler({
  onManifest() {
    return {
      defaultOutput: "../generated/effect",
      prettyName: "Prisma Effect Generator",
      requiresEngines: ["queryEngine"],
    };
  },

  async onGenerate(options: GeneratorOptions) {
    const models = options.dmmf.datamodel.models;
    const outputDir = options.generator.output?.value;

    if (!outputDir) {
      throw new Error("No output directory specified");
    }

    // Clean output directory
    await fs.rm(outputDir, { recursive: true, force: true });
    await fs.mkdir(outputDir, { recursive: true });

    // Generate unified index file with PrismaService
    await generateUnifiedService([...models], outputDir);

    // Generate types file
    await generateTypes([...models], outputDir);
  },
});

function generateRawSqlOperations() {
  return `
    $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.tryPromise({
        try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
        catch: (error) =>
          new PrismaError({
            error,
            operation: "$executeRaw",
            model: "Prisma"
          })
      }),

    $executeRawUnsafe: (query: string, ...values: any[]) =>
      Effect.tryPromise({
        try: () => client.$executeRawUnsafe(query, ...values),
        catch: (error) =>
          new PrismaError({
            error,
            operation: "$executeRawUnsafe",
            model: "Prisma"
          })
      }),

    $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.tryPromise({
        try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)),
        catch: (error) =>
          new PrismaError({
            error,
            operation: "$queryRaw",
            model: "Prisma"
          })
      }),

    $queryRawUnsafe: (query: string, ...values: any[]) =>
      Effect.tryPromise({
        try: () => client.$queryRawUnsafe(query, ...values),
        catch: (error) =>
          new PrismaError({
            error,
            operation: "$queryRawUnsafe",
            model: "Prisma"
          })
      }),`;
}

function generateModelOperations(models: DMMF.Model[]) {
  return models
    .map((model) => {
      const modelName = model.name;
      const modelNameCamel = toCamelCase(modelName);

      return `    ${modelNameCamel}: {
      // Find operations
      findMany: (args?: Prisma.${modelName}FindManyArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.findMany(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findMany",
              model: "${modelName}"
            })
        }),

      findUnique: (args: Prisma.${modelName}FindUniqueArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.findUnique(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findUnique",
              model: "${modelName}"
            })
        }),

      findFirst: (args?: Prisma.${modelName}FindFirstArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.findFirst(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findFirst",
              model: "${modelName}"
            })
        }),

      findUniqueOrThrow: (args: Prisma.${modelName}FindUniqueOrThrowArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.findUniqueOrThrow(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findUniqueOrThrow",
              model: "${modelName}"
            })
        }),

      findFirstOrThrow: (args?: Prisma.${modelName}FindFirstOrThrowArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.findFirstOrThrow(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "findFirstOrThrow",
              model: "${modelName}"
            })
        }),

      // Create operations
      create: (args: Prisma.${modelName}CreateArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.create(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "create",
              model: "${modelName}"
            })
        }),

      createMany: (args: Prisma.${modelName}CreateManyArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.createMany(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "createMany",
              model: "${modelName}"
            })
        }),

      createManyAndReturn: (args: Prisma.${modelName}CreateManyAndReturnArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.createManyAndReturn(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "createManyAndReturn",
              model: "${modelName}"
            })
        }),

      // Update operations
      update: (args: Prisma.${modelName}UpdateArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.update(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "update",
              model: "${modelName}"
            })
        }),

      updateMany: (args: Prisma.${modelName}UpdateManyArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.updateMany(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "updateMany",
              model: "${modelName}"
            })
        }),

      upsert: (args: Prisma.${modelName}UpsertArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.upsert(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "upsert",
              model: "${modelName}"
            })
        }),

      // Delete operations
      delete: (args: Prisma.${modelName}DeleteArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.delete(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "delete",
              model: "${modelName}"
            })
        }),

      deleteMany: (args?: Prisma.${modelName}DeleteManyArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.deleteMany(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "deleteMany",
              model: "${modelName}"
            })
        }),

      // Aggregation operations
      count: (args?: Prisma.${modelName}CountArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.count(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "count",
              model: "${modelName}"
            })
        }),

      aggregate: (args: Prisma.${modelName}AggregateArgs) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.aggregate(args),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "aggregate",
              model: "${modelName}"
            })
        }),

      groupBy: <T extends Prisma.${modelName}GroupByArgs>(args: T) =>
        Effect.tryPromise({
          try: () => client.${modelNameCamel}.groupBy(args as any),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "groupBy",
              model: "${modelName}"
            })
        })
    }`;
    })
    .join(",\n\n");
}

async function generateUnifiedService(models: DMMF.Model[], outputDir: string) {
  const rawSqlOperations = generateRawSqlOperations();
  const modelOperations = generateModelOperations(models);

  const serviceContent = `${header}
import { Context, Data, Effect, Layer } from "effect"
import { Service } from "effect/Effect"
import { type Prisma, PrismaClient } from "@prisma/client"
import { type EffectPrismaService } from "./types.js"

export class PrismaClientService extends Context.Tag("PrismaClientService")<
  PrismaClientService,
  {
    tx: PrismaClient | Prisma.TransactionClient
    client: PrismaClient
  }
>() {}

export const LivePrismaLayer = Layer.effect(
  PrismaClientService,
  Effect.sync(() => {
    const prisma = new PrismaClient()
    return {
      // The \`tx\` property (transaction) can be shared and overridden,
      // but the \`client\` property must always be a PrismaClient instance.
      tx: prisma,
      client: prisma
    }
  })
)

export class PrismaError extends Data.TaggedError("PrismaError")<{
  error: unknown
  operation: string
  model: string
}> {}

export class PrismaService extends Service<PrismaService>()("PrismaService", {
  effect: Effect.gen(function* () {
    const { tx: client } = yield* PrismaClientService
    return {
      ${rawSqlOperations}

      ${modelOperations}
    } as unknown as EffectPrismaService
  })
}) {}
`;

  await fs.writeFile(path.join(outputDir, "index.ts"), serviceContent);
}

async function generateTypes(models: DMMF.Model[], outputDir: string) {
  const modelTypeDefinitions = models
    .map((model) => {
      const modelName = model.name;
      const modelNameCamel = toCamelCase(modelName);

      return `  ${modelNameCamel}: {
    findMany: <T extends Prisma.${modelName}FindManyArgs>(args?: T) => Effect.Effect<Array<Prisma.${modelName}GetPayload<T>>, PrismaError>
    findUnique: <T extends Prisma.${modelName}FindUniqueArgs>(args: T) => Effect.Effect<Prisma.${modelName}GetPayload<T> | null, PrismaError>
    findFirst: <T extends Prisma.${modelName}FindFirstArgs>(args?: T) => Effect.Effect<Prisma.${modelName}GetPayload<T> | null, PrismaError>
    findUniqueOrThrow: <T extends Prisma.${modelName}FindUniqueOrThrowArgs>(args: T) => Effect.Effect<Prisma.${modelName}GetPayload<T>, PrismaError>
    findFirstOrThrow: <T extends Prisma.${modelName}FindFirstOrThrowArgs>(args?: T) => Effect.Effect<Prisma.${modelName}GetPayload<T>, PrismaError>
    create: <T extends Prisma.${modelName}CreateArgs>(args: T) => Effect.Effect<Prisma.${modelName}GetPayload<T>, PrismaError>
    createMany: (args: Prisma.${modelName}CreateManyArgs) => Effect.Effect<Prisma.BatchPayload, PrismaError>
    createManyAndReturn: <T extends Prisma.${modelName}CreateManyAndReturnArgs>(args: T) => Effect.Effect<Array<Prisma.${modelName}GetPayload<T>>, PrismaError>
    update: <T extends Prisma.${modelName}UpdateArgs>(args: T) => Effect.Effect<Prisma.${modelName}GetPayload<T>, PrismaError>
    updateMany: (args: Prisma.${modelName}UpdateManyArgs) => Effect.Effect<Prisma.BatchPayload, PrismaError>
    upsert: <T extends Prisma.${modelName}UpsertArgs>(args: T) => Effect.Effect<Prisma.${modelName}GetPayload<T>, PrismaError>
    delete: <T extends Prisma.${modelName}DeleteArgs>(args: T) => Effect.Effect<Prisma.${modelName}GetPayload<T>, PrismaError>
    deleteMany: (args?: Prisma.${modelName}DeleteManyArgs) => Effect.Effect<Prisma.BatchPayload, PrismaError>
    count: (args?: Prisma.${modelName}CountArgs) => Effect.Effect<number, PrismaError>
    aggregate: <T extends Prisma.${modelName}AggregateArgs>(args: T) => Effect.Effect<Prisma.GetScalarType<T, Prisma.${modelName}GetPayload<T>>, PrismaError>
    groupBy: <T extends Prisma.${modelName}GroupByArgs>(args: T) => Effect.Effect<any, PrismaError> // Complexity of GroupBy types is high, falling back to any for now or basic checks
  }`;
    })
    .join("\n");

  const typeContent = `${header}
import type { Effect } from "effect"
import type { Prisma } from "@prisma/client"
import type { PrismaError } from "./index.js"

export type EffectPrismaService = {
  $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) => Effect.Effect<number, PrismaError>
  $executeRawUnsafe: (query: string, ...values: any[]) => Effect.Effect<number, PrismaError>
  $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) => Effect.Effect<unknown, PrismaError>
  $queryRawUnsafe: (query: string, ...values: any[]) => Effect.Effect<unknown, PrismaError>
  ${modelTypeDefinitions}
}
`;

  await fs.writeFile(path.join(outputDir, "types.ts"), typeContent);
}

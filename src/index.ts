#!/usr/bin/env node
import { DMMF } from "@prisma/client/runtime/library";
import type { GeneratorOptions } from "@prisma/generator";
import { generatorHandler } from "@prisma/generator-helper";
import fs from "node:fs/promises";
import path from "node:path";

const header = `// This file was generated by prisma-effect-generator, do not edit manually.\n`;

// Utility function to convert PascalCase to camelCase
function toCamelCase(str: string) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

generatorHandler({
  onManifest() {
    return {
      defaultOutput: "../generated/effect",
      prettyName: "Prisma Effect Generator",
      requiresEngines: ["queryEngine"],
    };
  },

  async onGenerate(options: GeneratorOptions) {
    const models = options.dmmf.datamodel.models;
    const outputDir = options.generator.output?.value;
    const configPath = options.generator.config.clientImportPath;
    const clientImportPath = Array.isArray(configPath)
      ? configPath[0]
      : (configPath ?? "@prisma/client");

    if (!outputDir) {
      throw new Error("No output directory specified");
    }

    // Clean output directory
    await fs.rm(outputDir, { recursive: true, force: true });
    await fs.mkdir(outputDir, { recursive: true });

    // Generate unified index file with PrismaService
    await generateUnifiedService([...models], outputDir, clientImportPath);
  },
});

function generateRawSqlOperations() {
  return `
    $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.flatMap(PrismaClientService, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "$executeRaw",
              model: "Prisma"
            })
        })
      ),

    $executeRawUnsafe: (query: string, ...values: any[]) =>
      Effect.flatMap(PrismaClientService, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => client.$executeRawUnsafe(query, ...values),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "$executeRawUnsafe",
              model: "Prisma"
            })
        })
      ),

    $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.flatMap(PrismaClientService, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "$queryRaw",
              model: "Prisma"
            })
        })
      ),

    $queryRawUnsafe: (query: string, ...values: any[]) =>
      Effect.flatMap(PrismaClientService, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => client.$queryRawUnsafe(query, ...values),
          catch: (error) =>
            new PrismaError({
              error,
              operation: "$queryRawUnsafe",
              model: "Prisma"
            })
        })
      ),`;
}

function generateModelOperations(models: DMMF.Model[]) {
  return models
    .map((model) => {
      const modelName = model.name;
      const modelNameCamel = toCamelCase(modelName);

      return `    ${modelNameCamel}: {
      findUnique: (args: Parameters<PrismaClient['${modelNameCamel}']['findUnique']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUnique(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "findUnique",
                model: "${modelName}"
              })
          })
        ),

      findUniqueOrThrow: (args: Parameters<PrismaClient['${modelNameCamel}']['findUniqueOrThrow']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUniqueOrThrow(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "findUniqueOrThrow",
                model: "${modelName}"
              })
          })
        ),

      findFirst: (args?: Parameters<PrismaClient['${modelNameCamel}']['findFirst']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirst(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "findFirst",
                model: "${modelName}"
              })
          })
        ),

      findFirstOrThrow: (args?: Parameters<PrismaClient['${modelNameCamel}']['findFirstOrThrow']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirstOrThrow(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "findFirstOrThrow",
                model: "${modelName}"
              })
          })
        ),

      findMany: (args?: Parameters<PrismaClient['${modelNameCamel}']['findMany']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findMany(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "findMany",
                model: "${modelName}"
              })
          })
        ),

      create: (args: Parameters<PrismaClient['${modelNameCamel}']['create']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.create(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "create",
                model: "${modelName}"
              })
          })
        ),

      createMany: (args?: Parameters<PrismaClient['${modelNameCamel}']['createMany']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createMany(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "createMany",
                model: "${modelName}"
              })
          })
        ),

      createManyAndReturn: (args?: Parameters<PrismaClient['${modelNameCamel}']['createManyAndReturn']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createManyAndReturn(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "createManyAndReturn",
                model: "${modelName}"
              })
          })
        ),

      delete: (args: Parameters<PrismaClient['${modelNameCamel}']['delete']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.delete(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "delete",
                model: "${modelName}"
              })
          })
        ),

      update: (args: Parameters<PrismaClient['${modelNameCamel}']['update']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.update(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "update",
                model: "${modelName}"
              })
          })
        ),

      deleteMany: (args?: Parameters<PrismaClient['${modelNameCamel}']['deleteMany']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.deleteMany(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "deleteMany",
                model: "${modelName}"
              })
          })
        ),

      updateMany: (args: Parameters<PrismaClient['${modelNameCamel}']['updateMany']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateMany(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "updateMany",
                model: "${modelName}"
              })
          })
        ),

      updateManyAndReturn: (args: Parameters<PrismaClient['${modelNameCamel}']['updateManyAndReturn']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateManyAndReturn(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "updateManyAndReturn",
                model: "${modelName}"
              })
          })
        ),

      upsert: (args: Parameters<PrismaClient['${modelNameCamel}']['upsert']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.upsert(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "upsert",
                model: "${modelName}"
              })
          })
        ),

      // Aggregation operations
      count: (args?: Parameters<PrismaClient['${modelNameCamel}']['count']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.count(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "count",
                model: "${modelName}"
              })
          })
        ),

      aggregate: (args: Parameters<PrismaClient['${modelNameCamel}']['aggregate']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.aggregate(args),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "aggregate",
                model: "${modelName}"
              })
          })
        ),

      groupBy: (args: Parameters<PrismaClient['${modelNameCamel}']['groupBy']>[0]) =>
        Effect.flatMap(PrismaClientService, ({ tx: client }) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.groupBy(args as any),
            catch: (error) =>
              new PrismaError({
                error,
                operation: "groupBy",
                model: "${modelName}"
              })
          })
        )
    }`;
    })
    .join(",\n\n");
}

async function generateUnifiedService(
  models: DMMF.Model[],
  outputDir: string,
  clientImportPath: string,
) {
  const rawSqlOperations = generateRawSqlOperations();
  const modelOperations = generateModelOperations(models);

  const serviceContent = `${header}
import { Context, Data, Effect, Layer, Runtime } from "effect"
import { Service } from "effect/Effect"
import { type Prisma, PrismaClient } from "${clientImportPath}"

export class PrismaClientService extends Context.Tag("PrismaClientService")<
  PrismaClientService,
  {
    tx: PrismaClient | Prisma.TransactionClient
    client: PrismaClient
  }
>() {}

export const LivePrismaLayer = Layer.effect(
  PrismaClientService,
  Effect.sync(() => {
    const prisma = new PrismaClient()
    return {
      // The \`tx\` property (transaction) can be shared and overridden,
      // but the \`client\` property must always be a PrismaClient instance.
      tx: prisma,
      client: prisma
    }
  })
)

export class PrismaError extends Data.TaggedError("PrismaError")<{
  error: unknown
  operation: string
  model: string
}> {}

export class PrismaService extends Service<PrismaService>()("PrismaService", {
  effect: Effect.gen(function* () {
    return {
      $transaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: {
          maxWait?: number
          timeout?: number
          isolationLevel?: Prisma.TransactionIsolationLevel
        }
      ) =>
        Effect.flatMap(
          Effect.all([PrismaClientService, Effect.runtime<R>()]),
          ([{ client }, runtime]): Effect.Effect<A, E | PrismaError, R> => {
            const isRootClient = "$transaction" in tx;
            if (!isRootClient) {
              return effect
            }
            return Effect.tryPromise({
              try: () =>
                client.$transaction(
                  async (tx) => {
                    return await Runtime.runPromise(runtime)(
                      effect.pipe(
                        Effect.provideService(PrismaClientService, {
                          tx,
                          client,
                        })
                      ) as Effect.Effect<A, E, R>
                    )
                  },
                  options
                ),
              catch: (error) =>
                new PrismaError({
                  error,
                  operation: "$transaction",
                  model: "Prisma",
                }),
            })
          }
        ),
      ${rawSqlOperations}

      ${modelOperations}
    }
  })
}) {}
`;

  await fs.writeFile(path.join(outputDir, "index.ts"), serviceContent);
}
